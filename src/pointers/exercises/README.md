# ポインタ基礎 - 演習課題

## 基礎問題

### 演習10-1: ポインタの基本操作

2つの整数変数の値をポインタを使って交換するプログラムを作成してください。

**要件:**
- 2つの整数変数を宣言・初期化
- ポインタを使った値の交換関数を実装
- 交換前後の値とアドレスを表示
- 直接的な値の交換とポインタ経由の交換を比較

**期待される出力例:**
```
交換前: a = 10 (アドレス: 0x7fffbffac), b = 20 (アドレス: 0x7fffbffa8)
ポインタを使った交換実行...
交換後: a = 20 (アドレス: 0x7fffbffac), b = 10 (アドレス: 0x7fffbffa8)
```

### 演習10-2: 配列とポインタ

ポインタ演算を使って配列の要素を逆順に表示するプログラムを作成してください。

**要件:**
- 整数配列を宣言・初期化
- ポインタ演算で配列の最後から最初に向かってアクセス
- インデックス記法とポインタ記法の両方で表示
- 配列のサイズを動的に計算

**期待される出力例:**
```
配列の内容（順方向）:
インデックス記法: arr[0]=1, arr[1]=2, arr[2]=3, arr[3]=4, arr[4]=5
ポインタ記法: *ptr=1, *(ptr+1)=2, *(ptr+2)=3, *(ptr+3)=4, *(ptr+4)=5

配列の内容（逆順）:
ポインタ演算で逆順表示: 5 4 3 2 1

各要素のアドレス:
&arr[0] = 0x7fffc000
&arr[1] = 0x7fffc004
&arr[2] = 0x7fffc008
&arr[3] = 0x7fffc00c
&arr[4] = 0x7fffc010
```

### 演習10-3: 文字列操作

ポインタを使って文字列の長さを計算し、文字列を逆順にするプログラムを作成してください。

**要件:**
- 文字列の長さ計算関数（strlen相当）をポインタで実装
- 文字列を逆順にする関数をポインタで実装
- 元の文字列と逆順文字列を表示
- 文字列リテラルと文字配列の違いを考慮

**期待される出力例:**
```
文字列操作プログラム
文字列を入力: Hello World

元の文字列: Hello World
文字列の長さ: 11文字

文字列を逆順に変換中...
逆順文字列: dlroW olleH

各文字とそのアドレス:
'H' at 0x7fffc100
'e' at 0x7fffc101
'l' at 0x7fffc102
... (以下省略)
```

## 応用問題

### 演習10-4: 配列操作関数

ポインタを使って配列の最大値、最小値、平均値を計算する関数群を作成してください。

**要件:**
- 最大値を見つけてそのポインタを返す関数
- 最小値を見つけてそのポインタを返す関数
- 平均値を計算する関数（戻り値はdouble）
- 各関数の結果を使ってレポートを作成

**実装する関数:**
```c
int* find_max(int *arr, int size);
int* find_min(int *arr, int size);
double calculate_average(int *arr, int size);
void print_statistics(int *arr, int size);
```

**期待される出力例:**
```
配列統計分析プログラム
配列: 34 12 67 89 23 45 78 56 90 11

=== 統計情報 ===
最大値: 90 (アドレス: 0x7fffc120, インデックス: 8)
最小値: 11 (アドレス: 0x7fffc124, インデックス: 9)
平均値: 50.50

値の範囲: 11 〜 90
```

### 演習10-5: 文字列処理

ポインタを使って文字列の検索、置換、分割を実行する関数群を作成してください。

**要件:**
- 文字列内で特定の文字を検索する関数
- 文字列内の文字を置換する関数
- 文字列を特定の文字で分割する関数
- 大文字・小文字を無視した比較機能

**期待される出力例:**
```
文字列処理プログラム
文字列: Hello,World,Programming

文字 'o' の検索:
見つかった位置: 4, 7, 18

文字 'o' を 'O' に置換:
置換後: HellO,WOrld,PrOgramming

カンマで分割:
1: Hello
2: World
3: Programming

大文字小文字を無視した検索 ('w'):
見つかった位置: 6 (W)
```

### 演習10-6: データ変換

ポインタを使って配列のデータ型変換を実行するプログラムを作成してください。

**要件:**
- int配列をfloat配列に変換
- 文字列を数値配列に変換
- バイト配列を整数として解釈
- エラーハンドリングの実装

**期待される出力例:**
```
データ型変換プログラム

=== int配列からfloat配列への変換 ===
元のint配列: 10, 20, 30, 40, 50
変換後のfloat配列: 10.00, 20.00, 30.00, 40.00, 50.00

=== 文字列から数値配列への変換 ===
文字列: "12 34 56 78 90"
数値配列: 12, 34, 56, 78, 90

=== バイト配列を整数として解釈 ===
バイト配列: 0x01 0x02 0x03 0x04
リトルエンディアン解釈: 67305985 (0x04030201)
ビッグエンディアン解釈: 16909060 (0x01020304)
```

## 発展問題

### 演習10-7: メモリ操作

ポインタを使って任意のデータ型の配列をコピーする汎用関数を作成してください。

**要件:**
- void*ポインタを使った汎用コピー関数
- バイト単位でのメモリコピー
- 型安全性の考慮
- コピー対象の境界チェック

**関数プロトタイプ:**
```c
void* generic_copy(void *dest, const void *src, size_t size);
int compare_memory(const void *ptr, const void *ptr, size_t size);
```

### 演習10-8: アルゴリズム実装

ポインタを使って各種ソートアルゴリズムを実装してください。

**要件:**
- バブルソート（ポインタ版）
- 選択ソート（ポインタ版）
- 挿入ソート（ポインタ版）
- 汎用的な比較関数の使用

### 演習10-9: データ構造

ポインタを使って簡単なリンクリスト構造を実装してください。

**要件:**
- ノード構造体の定義
- リストへの要素追加・削除
- リストの走査・検索
- メモリリークの防止

**構造体例:**
```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;
```

## チャレンジ問題

### 演習10-10: 動的配列シミュレータ

malloc/freeを使わずに、静的配列とポインタを使って動的配列のような動作を実現してください。

**要件:**
- 固定サイズの大きな配列をメモリプールとして使用
- 要素の追加・削除・挿入機能
- メモリの断片化管理
- ガベージコレクション機能

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex_pointer_swap.c`, `ex_array_reverse.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex_pointer_swap.c -o ex_pointer_swap
./ex_pointer_swap
```

## ヒント

### ポインタの基本
- 宣言: `int *ptr;`
- アドレス取得: `ptr = &variable;`
- 値の取得: `value = *ptr;`
- 演算: `ptr + 1` は次の要素を指す

### 安全なプログラミング
- NULLポインタのチェック: `if (ptr != NULL)`
- 配列の境界チェック
- 初期化されていないポインタの使用を避ける

### デバッグのコツ
- アドレスと値を分けて表示
- ポインタ演算の結果を段階的に確認
- コンパイラの警告に注意を払う

### よくある間違い
- `*ptr++` と `(*ptr)++` の違い
- ローカル変数のアドレスを返すこと
- 配列の範囲外アクセス
- NULLポインタの参照