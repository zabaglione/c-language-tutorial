# 配列
##  対応C規格
- **主要対象:** C90
- **学習内容:** 一次元配列、多次元配列、配列の初期化、配列とポインタの関係

##  学習目標
この章を完了すると、以下のことができるようになります：
- 一次元配列の宣言・初期化・使用ができる
- 多次元配列を理解して活用できる
- 数値配列の操作（検索、ソート、統計計算）ができる
- 配列とポインタの関係を理解できる
- 配列を使った実践的なプログラムを作成できる

##  概要と詳細

### 配列とは？
配列（はいれつ）は、プログラミングで最も重要なデータ構造の一つです。

#### 日常生活での配列
配列を理解するために、身近な例を考えてみましょう：

1. **教室の座席**
   - 5行6列の座席 = 2次元配列
   - 各座席には生徒が座る = 配列の要素
   - 「3行目の4番目の席」= 配列の[3][4]

2. **アパートの部屋番号**
   - 101号室、102号室... = 1次元配列
   - 各部屋に住人がいる = 配列の要素

3. **カレンダー**
   - 曜日×週 = 2次元配列
   - 各マスに日付 = 配列の要素

#### なぜ配列が必要なの？
配列がないと、たくさんのデータを扱うのが大変になります。例えば5人の点数を管理する場合、配列なしでは変数を5つ作る必要がありますが、配列を使えば1つの変数で管理でき、100人でも1000人でも簡単に管理できます。

### 配列の基本概念 
配列は同じデータ型の要素を連続したメモリ領域に格納するデータ構造です。

#### 1次元配列の宣言
```c
データ型 配列名[要素数];
```

例えば、5つの整数を格納する配列は以下のように宣言します：
```c
int numbers[5];  /* 5つのint型要素を持つ配列 */
```

### 配列の初期化 
配列を使用する前に適切な値で初期化することが重要です。

#### 宣言時の初期化
```c
int numbers[5] = {10, 20, 30, 40, 50};
```

#### 部分的な初期化
```c
int numbers[5] = {10, 20};  /* 残りの3つは0で初期化される */
```

#### サイズを省略した初期化
```c
int numbers[] = {10, 20, 30, 40, 50};  /* コンパイラが自動的にサイズを決定 */
```

### 配列の操作 
配列の要素にアクセスするには、添字（インデックス）を使用します。

#### 要素へのアクセス
```c
numbers[0] = 10;    /* 最初の要素に値を代入 */
int value = numbers[2];  /* 3番目の要素の値を取得 */
```

**重要な注意点：**
- 配列の添字は0から始まります
- 要素数がnの配列の有効な添字は0からn-1まで
- 範囲外アクセスは未定義動作を引き起こします

### 配列の応用操作
数値配列では以下のような操作が頻繁に行われます：

#### 配列の検索
```c
int search_value(int arr[], int size, int target) {
    int i;
    for (i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i;  /* 見つかった位置を返す */
        }
    }
    return -1;  /* 見つからなかった */
}
```

#### 配列の統計計算
```c
/* 最大値を見つける */
int find_max(int arr[], int size) {
    int max = arr[0];
    int i;
    for (i = 1; i < size; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

/* 平均値を計算する */
double calculate_average(int arr[], int size) {
    int sum = 0;
    int i;
    for (i = 0; i < size; i++) {
        sum += arr[i];
    }
    return (double)sum / size;
}
```

### 多次元配列 
配列の配列を作ることで、表やマトリックスのような構造を表現できます。

#### 2次元配列の宣言
```c
int matrix[3][4];  /* 3行4列の配列 */
```

#### 2次元配列の初期化
```c
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

#### 3次元配列
```c
int cube[2][3][4];  /* 2×3×4の3次元配列 */
```

### 配列の実践的応用 
配列は様々な場面で活用できます：

1. **統計計算** - 数値の集合から平均、最大値、最小値を計算
2. **データ検索** - 特定の値を配列から探す
3. **ソート** - データを昇順や降順に並べ替える
4. **行列演算** - 数学的な行列計算
5. **画像処理** - 画素データの管理

### 配列とポインタの関係 
C言語では配列名は最初の要素へのポインタとして扱われます。

#### 配列名とポインタ
```c
int arr[5] = {1, 2, 3, 4, 5};
```

この場合、`arr`は`&arr[0]`と同じ意味になります。

## 実例コード
完全な実装例は以下のファイルを参照してください：

### 基本的な配列操作
- [array_basics.c](examples/array_basics.c) - C90準拠版
- [array_basics_c99.c](examples/array_basics_c99.c) - C99準拠版

### 多次元配列の活用
- [multidimensional_arrays.c](examples/multidimensional_arrays.c) - C90準拠版
- [multidimensional_arrays_c99.c](examples/multidimensional_arrays_c99.c) - C99準拠版

## コンパイル方法

### 基本的なコンパイル（C90準拠）
```bash
gcc -std=c90 -Wall -Wextra -pedantic array_basics.c -o array_basics
```

### Makefileを使用した場合
```bash
# 全てのプログラムをコンパイル
make all
# 特定のプログラムをコンパイル  
make array_basics
# C99版をコンパイル
make array_basics_c99
# プログラムを実行
make run-all
# クリーンアップ
make clean
```

## 学習フローとコンパイル方法

### 推奨学習順序
1. **理論学習**: README.mdで基本概念を理解
2. **サンプルコード**: examples/の基本例を確認
3. **演習課題**: exercises/README.mdで課題を確認
4. **実装練習**: solutions/の解答例を参考に自分で実装

### Makefileを使用したコンパイル
```bash
# 全てのプログラムをコンパイル
make all

# 特定のプログラムをコンパイル
make array_basics

# C99版をコンパイル
make array_basics_c99

# プログラムを実行
make run-all

# クリーンアップ
make clean
```

### 手動コンパイル
```bash
# C90準拠
gcc -std=c90 -Wall -Wextra -pedantic examples/array_basics.c -o array_basics

# C99準拠
gcc -std=c99 -Wall -Wextra -pedantic examples/array_basics_c99.c -o array_basics_c99
```

## C90とC99の違い

### C90の特徴（このチュートリアルの基準）
- **変数宣言**: 関数の先頭でまとめて宣言する必要がある
- **配列サイズ**: コンパイル時に決定される固定サイズのみ
- **初期化**: 宣言と同時に行う必要がある
- **コメント**: `/* */` 形式のみ使用可能

### C99の拡張機能
- **変数宣言**: 使用する場所で宣言可能
- **可変長配列（VLA）**: 実行時にサイズを決定可能
- **配列の指定初期化**: `arr[5] = {[2] = 10, [4] = 20}`
- **行コメント**: `//` 形式のコメントが使用可能

### このチュートリアルでの方針
- 基本はC90準拠で説明し、C99の拡張機能は別ファイルで提供
- C90版とC99版の両方のコード例を用意
- 実際の開発では使用する環境に応じて選択

## よくある間違いとデバッグ方法

### 1. 配列の境界外アクセス
**問題:** 配列のサイズを超えた添字でアクセス
```c
int arr[5] = {1, 2, 3, 4, 5};
int value = arr[5];  /* エラー：添字は0-4が有効 */
```

**対策:**
- 常に配列のサイズを意識する
- ループの条件を正しく設定する
- デバッガーやランタイムチェックツールを使用

### 2. 文字列配列の初期化忘れ
**問題:** 文字列配列が適切に初期化されていない
```c
char str[20];
printf("%s", str);  /* 未初期化の文字列を出力 */
```

**対策:**
- 使用前に必ず初期化する
- `strcpy()`や`memset()`を使用
- 宣言時に初期化を同時に行う

### 3. 配列代入の間違い
**問題:** 配列全体を直接代入しようとする
```c
int arr1[5] = {1, 2, 3, 4, 5};
int arr2[5];
arr2 = arr1;  /* エラー：配列は直接代入不可 */
```

**対策:**
- ループを使用して要素を1つずつコピー
- `memcpy()`関数を使用
- ポインタを使用する場合は注意深く設計

### 4. C90とC99の混在エラー
**問題:** C90環境でC99の機能を使用
```c
/* C90環境では以下はエラー */
int n = 5;
int arr[n];  /* 可変長配列はC99から */
```

**対策:**
- 使用するC標準を明確にする
- コンパイラオプションで標準を指定
- 環境に応じたコードを作成

### デバッグのコツ
- **printfデバッグ**: 配列の内容を出力して確認
- **静的解析ツール**: cppcheckなどを使用
- **メモリチェックツール**: valgrindなどを使用（Linuxの場合）
- **解答例との比較**: solutions/の正解コードと比較して違いを確認

##  次の章へ
[第8章: 文字列処理](../strings/README.md) - 文字列配列の詳細はこちら

##  参考資料
- examples/ - 実装例（C90、C99両対応）
- exercises/ - 演習問題
- solutions/ - 解答例
- [C90規格書](https://www.iso.org/standard/17782.html)
- [C99規格書](https://www.iso.org/standard/29237.html)