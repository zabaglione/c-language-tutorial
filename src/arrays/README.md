# 配列
##  対応C規格
- **主要対象:** C90
- **学習内容:** 一次元配列、多次元配列、配列の初期化、配列とポインタの関係

##  学習目標
この章を完了すると、以下のことができるようになります。
- 一次元配列の宣言・初期化・使用ができる
- 多次元配列を理解して活用できる
- 数値配列の操作（検索、ソート、統計計算）ができる
- 配列とポインタの関係を理解できる
- 配列を使った実践的なプログラムを作成できる

##  概要と詳細

### 配列とは？
配列（はいれつ）は、プログラミングで最も重要なデータ構造の一つです。

#### 日常生活での配列
配列を理解するために、身近な例を考えてみましょう。

1. **教室の座席**
   - 5行6列の座席 = 2次元配列
   - 各座席には生徒が座る = 配列の要素
   - 「3行目の4番目の席」= 配列の[3][4]

2. **アパートの部屋番号**
   - 101号室、102号室... = 1次元配列
   - 各部屋に住人がいる = 配列の要素

3. **カレンダー**
   - 曜日×週 = 2次元配列
   - 各マスに日付 = 配列の要素

#### なぜ配列が必要なの？
配列がないと、たくさんのデータを扱うのが大変になります。例えば5人の点数を管理する場合、配列なしでは変数を5つ作る必要がありますが、配列を使えば1つの変数で管理でき、100人でも1000人でも簡単に管理できます。

### 配列の基本概念 
配列は同じデータ型の要素を連続したメモリ領域に格納するデータ構造です。

#### 配列の3つの重要な特徴

1. **同じ型の集まり**
   - すべての要素が同じデータ型でなければならない
   - int型の配列にはint型の値のみ格納可能

2. **連続したメモリ領域**
   - 要素は隣り合ったメモリ上に配置される
   - このため高速なアクセスが可能

3. **固定サイズ**
   - 配列のサイズは宣言時に決まり、後から変更できない
   - 動的なサイズ変更が必要な場合は動的メモリ確保を使用

#### 配列のメモリ上の配置

```
配列 int numbers[5] のメモリ配置：

アドレス:  1000    1004    1008    1012    1016
         +-------+-------+-------+-------+-------+
         |  [0]  |  [1]  |  [2]  |  [3]  |  [4]  |
         +-------+-------+-------+-------+-------+
         ↑
         配列の先頭アドレス（numbersが指す場所）
```

#### 1次元配列の宣言
```c
データ型 配列名[要素数];
```

例えば、5つの整数を格納する配列は以下のように宣言します。
```c
int numbers[5];  /* 5つのint型要素を持つ配列 */
```

#### 配列名の意味
配列名は配列の先頭要素へのアドレスを表します。
```c
int arr[5];
/* arr は &arr[0] と同じ（配列の先頭アドレス） */
```

### 配列の初期化 
配列を使用する前に適切な値で初期化することが重要です。

#### 宣言時の初期化
```c
int numbers[5] = {10, 20, 30, 40, 50};
```

#### 部分的な初期化
```c
int numbers[5] = {10, 20};  /* 残りの3つは0で初期化される */
```

#### サイズを省略した初期化
```c
int numbers[] = {10, 20, 30, 40, 50};  /* コンパイラが自動的にサイズを決定 */
```

### 配列の操作 
配列の要素にアクセスするには、添字（インデックス）を使用します。

#### 要素へのアクセス
```c
numbers[0] = 10;    /* 最初の要素に値を代入 */
int value = numbers[2];  /* 3番目の要素の値を取得 */
```

**重要な注意点：**
- 配列の添字は0から始まります
- 要素数がnの配列の有効な添字は0からn-1まで
- 範囲外アクセスは未定義動作を引き起こします

### 配列の応用操作
数値配列では以下のような操作が頻繁に行われます。ここでは関数を使わずに、mainプログラム内でのコード例を示します。

#### 配列内の値を検索する
```c
#include <stdio.h>

int main(void) {
    int numbers[10] = {3, 7, 1, 9, 4, 6, 8, 2, 5, 0};
    int target = 6;  /* 探したい値 */
    int found = -1;  /* 見つかった位置（-1は見つからない） */
    int i;
    
    /* 配列を検索 */
    for (i = 0; i < 10; i++) {
        if (numbers[i] == target) {
            found = i;  /* 見つかった位置を記録 */
            break;      /* 見つかったらループを抜ける */
        }
    }
    
    /* 結果を表示 */
    if (found != -1) {
        printf("%d は位置 %d にあります\n", target, found);
    } else {
        printf("%d は配列内にありません\n", target);
    }
    
    return 0;
}
```

#### 配列の統計計算（最大値・最小値・平均）
```c
#include <stdio.h>

int main(void) {
    int scores[5] = {85, 92, 78, 96, 88};
    int max, min, sum;
    double average;
    int i;
    
    /* 初期値の設定 */
    max = scores[0];
    min = scores[0];
    sum = scores[0];
    
    /* 2番目の要素から比較開始 */
    for (i = 1; i < 5; i++) {
        /* 最大値の更新 */
        if (scores[i] > max) {
            max = scores[i];
        }
        
        /* 最小値の更新 */
        if (scores[i] < min) {
            min = scores[i];
        }
        
        /* 合計に加算 */
        sum += scores[i];
    }
    
    /* 平均値の計算 */
    average = (double)sum / 5;
    
    /* 結果を表示 */
    printf("最大値: %d\n", max);
    printf("最小値: %d\n", min);
    printf("合計: %d\n", sum);
    printf("平均値: %.1f\n", average);
    
    return 0;
}
```

#### 配列の要素を逆順にする
```c
#include <stdio.h>

int main(void) {
    int arr[6] = {1, 2, 3, 4, 5, 6};
    int temp;
    int i;
    
    /* 元の配列を表示 */
    printf("元の配列: ");
    for (i = 0; i < 6; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    /* 配列を逆順にする */
    for (i = 0; i < 6 / 2; i++) {
        /* 前後の要素を交換 */
        temp = arr[i];
        arr[i] = arr[5 - i];
        arr[5 - i] = temp;
    }
    
    /* 逆順にした配列を表示 */
    printf("逆順配列: ");
    for (i = 0; i < 6; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    return 0;
}
```

### 多次元配列 
配列の配列を作ることで、表やマトリックスのような構造を表現できます。

#### 2次元配列の宣言
```c
int matrix[3][4];  /* 3行4列の配列 */
```

#### 2次元配列の初期化
```c
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

#### 3次元配列
```c
int cube[2][3][4];  /* 2×3×4の3次元配列 */
```

### 配列の実践的応用 
配列は様々な場面で活用できます。

1. **統計計算** - 数値の集合から平均、最大値、最小値を計算
2. **データ検索** - 特定の値を配列から探す
3. **ソート** - データを昇順や降順に並べ替える
4. **行列演算** - 数学的な行列計算
5. **画像処理** - 画素データの管理

### 配列とポインタの関係 
C言語において、配列とポインタには密接な関係があります。この関係を理解することは、C言語をマスターする上で非常に重要です。

#### 配列名の本質
配列名は、配列の最初の要素へのポインタとして扱われます。

```c
int arr[5] = {10, 20, 30, 40, 50};

/* 以下の3つは同じアドレスを示す */
printf("arr      = %p\n", arr);       /* 配列名 */
printf("&arr[0]  = %p\n", &arr[0]);   /* 最初の要素のアドレス */
printf("&arr     = %p\n", &arr);      /* 配列全体のアドレス（値は同じ） */
```

#### 配列要素へのアクセス方法の等価性

```c
int arr[5] = {10, 20, 30, 40, 50};
int i;

/* 以下の2つの方法は完全に等価 */
for (i = 0; i < 5; i++) {
    printf("arr[%d] = %d\n", i, arr[i]);        /* 配列記法 */
    printf("*(arr+%d) = %d\n", i, *(arr+i));    /* ポインタ記法 */
}

/* つまり、arr[i] は *(arr + i) の糖衣構文（シンタックスシュガー） */
```

#### 配列とポインタの違い

配列名はポインタのように振る舞いますが、重要な違いがあります。

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;  /* OK: 配列の先頭アドレスをポインタに代入 */

/* 配列名は定数（変更不可） */
arr = ptr;       /* エラー: 配列名への代入はできない */
arr++;           /* エラー: 配列名の変更はできない */

/* ポインタは変数（変更可能） */
ptr++;           /* OK: ポインタを次の要素に移動 */
ptr = &arr[3];   /* OK: ポインタに別のアドレスを代入 */
```

#### メモリ上での配列とポインタ

```
配列 int arr[5] の場合：
アドレス   内容
1000:     [10]  ← arr, &arr[0]
1004:     [20]  ← arr+1, &arr[1]
1008:     [30]  ← arr+2, &arr[2]
1012:     [40]  ← arr+3, &arr[3]
1016:     [50]  ← arr+4, &arr[4]

ポインタ演算：
arr + i は、arr から i要素分進んだアドレス
実際のアドレス = arr + (i * sizeof(int))
```

#### 関数への配列の渡し方（プレビュー）

配列を関数に渡すとき、実際には先頭要素へのポインタが渡されます。
```c
/* これらの宣言は同じ意味 */
void process_array(int arr[]);      /* 配列として宣言 */
void process_array(int *arr);       /* ポインタとして宣言 */
```

**注意**: 詳しい関数の使い方は「関数」の章で学習します。

## 実例コード
完全な実装例は以下のファイルを参照してください。

### 基本的な配列操作
- [array_basics.c](examples/array_basics.c) - C90準拠版
- [array_basics_c99.c](examples/array_basics_c99.c) - C99準拠版

### 多次元配列の活用
- [multidimensional_arrays.c](examples/multidimensional_arrays.c) - C90準拠版
- [multidimensional_arrays_c99.c](examples/multidimensional_arrays_c99.c) - C99準拠版

## コンパイル方法

### 基本的なコンパイル（C90準拠）
```bash
gcc -std=c90 -Wall -Wextra -pedantic array_basics.c -o array_basics
```

### Makefileを使用した場合
```bash
# 全てのプログラムをコンパイル
make all
# 特定のプログラムをコンパイル  
make array_basics
# C99版をコンパイル
make array_basics_c99
# プログラムを実行
make run-all
# クリーンアップ
make clean
```

## 学習フローとコンパイル方法

### 推奨学習順序
1. **理論学習**: README.mdで基本概念を理解
2. **サンプルコード**: examples/の基本例を確認
3. **演習課題**: exercises/README.mdで課題を確認
4. **実装練習**: solutions/の解答例を参考に自分で実装

### Makefileを使用したコンパイル
```bash
# 全てのプログラムをコンパイル
make all

# 特定のプログラムをコンパイル
make array_basics

# C99版をコンパイル
make array_basics_c99

# プログラムを実行
make run-all

# クリーンアップ
make clean
```

### 手動コンパイル
```bash
# C90準拠
gcc -std=c90 -Wall -Wextra -pedantic examples/array_basics.c -o array_basics

# C99準拠
gcc -std=c99 -Wall -Wextra -pedantic examples/array_basics_c99.c -o array_basics_c99
```

## C90とC99の違い

### C90の特徴（このチュートリアルの基準）
- **変数宣言**: 関数の先頭でまとめて宣言する必要がある
- **配列サイズ**: コンパイル時に決定される固定サイズのみ
- **初期化**: 宣言と同時に行う必要がある
- **コメント**: `/* */` 形式のみ使用可能

### C99の拡張機能
- **変数宣言**: 使用する場所で宣言可能
- **可変長配列（VLA）**: 実行時にサイズを決定可能
- **配列の指定初期化**: `arr[5] = {[2] = 10, [4] = 20}`
- **行コメント**: `//` 形式のコメントが使用可能

### このチュートリアルでの方針
- 基本はC90準拠で説明し、C99の拡張機能は別ファイルで提供
- C90版とC99版の両方のコード例を用意
- 実際の開発では使用する環境に応じて選択

## よくある間違いとデバッグ方法

### 1. 配列の境界外アクセス
**問題:** 配列のサイズを超えた添字でアクセス
```c
int arr[5] = {1, 2, 3, 4, 5};
int value = arr[5];  /* エラー：添字は0-4が有効 */
```

**対策:**
- 常に配列のサイズを意識する
- ループの条件を正しく設定する
- デバッガーやランタイムチェックツールを使用

### 2. 文字列配列の初期化忘れ
**問題:** 文字列配列が適切に初期化されていない
```c
char str[20];
printf("%s", str);  /* 未初期化の文字列を出力 */
```

**対策:**
- 使用前に必ず初期化する
- `strcpy()`や`memset()`を使用
- 宣言時に初期化を同時に行う

### 3. 配列代入の間違い
**問題:** 配列全体を直接代入しようとする
```c
int arr1[5] = {1, 2, 3, 4, 5};
int arr2[5];
arr2 = arr1;  /* エラー：配列は直接代入不可 */
```

**対策:**
- ループを使用して要素を1つずつコピー
- `memcpy()`関数を使用
- ポインタを使用する場合は注意深く設計

### 4. C90とC99の混在エラー
**問題:** C90環境でC99の機能を使用
```c
/* C90環境では以下はエラー */
int n = 5;
int arr[n];  /* 可変長配列はC99から */
```

**対策:**
- 使用するC標準を明確にする
- コンパイラオプションで標準を指定
- 環境に応じたコードを作成

### デバッグのコツ
- **printfデバッグ**: 配列の内容を出力して確認
- **静的解析ツール**: cppcheckなどを使用
- **メモリチェックツール**: valgrindなどを使用（Linuxの場合）
- **解答例との比較**: solutions/の正解コードと比較して違いを確認

##  次の章へ
配列を理解したら、[第8章: 文字列処理](../strings/README.md) に進んでください。

##  参考資料
- [C90規格書](https://www.iso.org/standard/17782.html)
- [C99規格書](https://www.iso.org/standard/29237.html)