# 第9章 関数 - 演習解答例

この章では、関数の基本から応用まで、様々な演習問題の解答例を提供しています。

## 解答ファイル一覧

### 演習9-1: 基本的な関数作成
素数判定や簡単な計算を行う基本的な関数群の実装例です。

- [ex11_1_prime_functions.c](ex11_1_prime_functions.c) - C90準拠版
- [ex11_1_prime_functions_c99.c](ex11_1_prime_functions_c99.c) - C99準拠版（bool型、//コメント使用）

**学習ポイント:**
- 関数の基本的な定義と呼び出し
- 引数と戻り値の扱い方
- ループと条件分岐の組み合わせ

### 演習9-2: 配列操作関数
配列に対する各種操作（合計、平均、ソート等）を行う関数群の実装例です。

- [ex11_2_array_operations.c](ex11_2_array_operations.c) - C90準拠版
- [ex11_2_array_operations_c99.c](ex11_2_array_operations_c99.c) - C99準拠版（可変長配列、inline関数使用）

**学習ポイント:**
- 配列を引数として受け取る方法
- ポインターを使った配列操作
- 動的メモリ割り当て（calloc/free）

### 演習9-3: 文字列処理関数
文字列の操作（コピー、連結、変換等）を行う関数群の実装例です。

- [ex11_3_string_processing.c](ex11_3_string_processing.c) - C90準拠版
- [ex11_3_string_processing_c99.c](ex11_3_string_processing_c99.c) - C99準拠版（bool型、inline関数使用）

**学習ポイント:**
- 文字配列としての文字列操作
- 標準ライブラリ関数の再実装
- 文字列の解析と変換

### 演習9-4: 複数戻り値を持つ関数
ポインター引数を使って複数の値を返す関数群の実装例です。

- [ex11_4_multiple_returns.c](ex11_4_multiple_returns.c) - C90準拠版
- [ex11_4_multiple_returns_c99.c](ex11_4_multiple_returns_c99.c) - C99準拠版（構造体戻り値、複合リテラル使用）

**学習ポイント:**
- ポインター引数による複数値の返却
- 構造体を使った複数値のまとめ方
- 数学的計算と座標変換

### 演習9-5: エラーハンドリング付き関数
エラー処理を含む堅牢な関数群の実装例です。

- [ex11_5_error_handling.c](ex11_5_error_handling.c) - C90準拠版
- [ex11_5_error_handling_c99.c](ex11_5_error_handling_c99.c) - C99準拠版（enum型、可変長引数マクロ使用）

**学習ポイント:**
- エラーコードの設計と管理
- 安全な数値計算（オーバーフロー対策）
- 境界チェックとNULLポインターチェック

### 演習9-6: 構造体を使った関数
構造体を引数や戻り値として使用する関数群の実装例です。

- [ex11_6_struct_functions.c](ex11_6_struct_functions.c) - C90準拠版
- [ex11_6_struct_functions_c99.c](ex11_6_struct_functions_c99.c) - C99準拠版（designated initializer、複合リテラル使用）

**学習ポイント:**
- 構造体の値渡しと参照渡し
- 構造体を返す関数の実装
- 複雑なデータ構造の操作

## コンパイルと実行

各解答例は以下のようにコンパイルできます。

```bash
# C90版のコンパイル例
gcc -Wall -Wextra -pedantic -std=c90 ex11_1_prime_functions.c -o ex11_1_prime

# C99版のコンパイル例（数学関数を使う場合は-lmを追加）
gcc -Wall -Wextra -pedantic -std=c99 ex11_4_multiple_returns_c99.c -lm -o ex11_4_c99

# 実行
./ex11_1_prime
```

## 学習のポイント

### 1. C90とC99の違い

各演習にはC90版とC99版の両方を用意しています。主な違いは。

- **変数宣言**: C90は関数の先頭、C99は使用箇所で宣言可能
- **コメント**: C90は`/* */`のみ、C99は`//`も使用可能
- **bool型**: C90は整数で代用、C99は`stdbool.h`の`bool`型
- **その他**: C99では可変長配列、複合リテラル、designated initializerなど

### 2. 関数設計の原則

- **単一責任の原則**: 1つの関数は1つの機能に集中
- **適切な名前付け**: 関数名から機能が推測できる
- **エラー処理**: 異常系を考慮した堅牢な実装
- **const修飾子**: 変更しない引数には`const`を付ける

### 3. テストの重要性

各解答例にはテスト用のmain関数が含まれています。

- 正常系のテスト
- 異常系のテスト（エラーケース）
- 境界値のテスト
- 実行結果の表示

### 4. メモリ管理

動的メモリを使用する場合。

- `malloc`/`calloc`で確保
- 使用後は必ず`free`で解放
- NULLチェックを忘れない
- メモリリークに注意

### 5. 移植性の考慮

- 標準ライブラリのみを使用
- プラットフォーム依存のコードを避ける
- 適切な型の使用（size_t、int64_tなど）

## 発展的な学習

これらの基本的な実装を理解したら、以下に挑戦してみましょう。

1. **最適化**: より効率的なアルゴリズムの実装
2. **拡張**: 新しい機能の追加
3. **汎用化**: より汎用的な関数の設計
4. **エラー処理の改善**: より詳細なエラー情報の提供

## 注意事項

- 実装例はあくまで一例です。他の実装方法も検討してみましょう
- 実際のプロジェクトでは、標準ライブラリの使用を推奨します
- セキュリティを考慮した実装を心がけましょう