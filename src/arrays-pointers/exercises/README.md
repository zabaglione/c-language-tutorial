# 第9章 演習問題: 配列とポインタ

## 演習の目的
- 配列とポインタの関係を深く理解する
- ポインタ演算を使った配列操作をマスターする
- 関数への配列の渡し方を習得する
- より効率的な配列処理技術を身につける

## 基礎問題

### 問題9-1: ポインタによる配列走査
ポインタを使って配列を操作するプログラムを作成してください。

**要件:**
- 10個の整数を配列に格納
- 以下の操作をポインタを使って実装:
  - 配列の全要素を表示（配列記法を使わない）
  - 最大値と最小値を見つける（ポインタ演算使用）
  - 配列を逆順に並べ替える（ポインタで実装）
  - 特定の値を検索し、そのアドレスを返す

**実装のヒント:**
- arr[i] の代わりに *(arr + i) を使用
- ポインタのインクリメント/デクリメントを活用

**期待される出力例:**
```
=== ポインタによる配列操作 ===
配列の内容: 34 67 12 89 23 45 78 56 90 11

ポインタ記法での表示:
*(ptr+0) = 34
*(ptr+1) = 67
*(ptr+2) = 12
... (続く)

最大値: 90 (アドレス: 0x7fffc120)
最小値: 11 (アドレス: 0x7fffc124)

配列を逆順に並べ替え中...
逆順配列: 11 90 56 78 45 23 89 12 67 34

値 45 を検索...
値 45 は アドレス 0x7fffc114 に見つかりました（インデックス: 5）
```

### 問題9-2: 関数への配列渡し
配列を関数に渡して操作するプログラムを作成してください。

**要件:**
- 配列操作を行う以下の関数を実装:
  - 配列の要素をすべてn倍する関数
  - 2つの配列を要素ごとに加算する関数
  - 配列内の最大値へのポインタを返す関数
  - 配列を指定位置で分割する関数

**実装のヒント:**
- 関数の引数は int *arr または int arr[]
- サイズ情報は別引数で渡す

**期待される出力例:**
```
=== 関数への配列渡し ===
元の配列: 1 2 3 4 5

配列の要素を3倍にする:
結果: 3 6 9 12 15

配列A: 10 20 30 40 50
配列B: 5 10 15 20 25
要素ごとの加算結果: 15 30 45 60 75

配列内の最大値: 75 (アドレス: 0x7fffc1a4)

配列を位置3で分割:
前半: 15 30 45
後半: 60 75
```

## 応用問題

### 問題9-3: 文字列のポインタ操作
文字列をポインタで操作するプログラムを作成してください。

**要件:**
- ポインタを使った以下の文字列関数を実装:
  - 文字列の長さを計算（strlen相当）
  - 文字列をコピー（strcpy相当）
  - 文字列を連結（strcat相当）
  - 文字列を反転

**実装のヒント:**
- char *を使った操作
- null終端文字の処理に注意

**期待される出力例:**
```
=== 文字列のポインタ操作 ===
文字列1: Hello
文字列2: World

my_strlen("Hello") = 5

文字列コピー実行...
コピー結果: Hello

文字列連結実行...
連結結果: HelloWorld

文字列反転実行...
反転結果: dlroWolleH
```

### 問題9-4: 多次元配列とポインタ
2次元配列をポインタで操作するプログラムを作成してください。

**要件:**
- 3×3の行列に対する以下の操作:
  - ポインタを使った要素アクセス
  - 行列の転置（ポインタ使用）
  - 対角要素の合計
  - 行ごと、列ごとの合計

**実装のヒント:**
- *(*(arr + i) + j) でアクセス
- int (*ptr)[3] の使い方を理解

**期待される出力例:**
```
=== 多次元配列とポインタ ===
元の行列:
1 2 3
4 5 6
7 8 9

ポインタを使った要素アクセス:
*(*(matrix+1)+1) = 5

転置行列:
1 4 7
2 5 8
3 6 9

対角要素の合計: 15 (1 + 5 + 9)

行ごとの合計: 6, 15, 24
列ごとの合計: 12, 15, 18
```

### 問題9-5: 動的配列の模擬
ポインタを使った配列の動的な操作を行うプログラムを作成してください。

**要件:**
- 固定サイズ配列を使いながら動的配列のような操作:
  - 使用中の要素数を管理
  - 要素の追加（容量チェック付き）
  - 要素の削除（詰める処理）
  - 配列の拡張（別の大きな配列へコピー）

**実装のヒント:**
- 実際の要素数と配列容量を別管理
- ポインタを使った効率的なコピー

**期待される出力例:**
```
=== 動的配列の模擬 ===
初期容量: 10, 使用中: 0

要素を追加: 10, 20, 30
現在の配列: [10, 20, 30]
容量: 10, 使用中: 3

要素 20 を削除...
現在の配列: [10, 30]
容量: 10, 使用中: 2

要素を追加して容量オーバー時の処理:
新しい容量: 20
配列の内容をコピー中...
拡張完了！
```

## チャレンジ問題

### 問題9-6: 高速文字列検索
ポインタを使った効率的な文字列検索アルゴリズムを実装してください。

**要件:**
- Boyer-Moore法の簡易版を実装:
  - 文字列内から部分文字列を検索
  - 見つかった位置のポインタを返す
  - 複数箇所で見つかる場合は全て表示

**追加要件:**
- 検索回数をカウントして効率性を評価
- 通常の逐次検索と比較

**期待される出力例:**
```
=== 高速文字列検索 ===
テキスト: "The quick brown fox jumps over the lazy dog"
検索パターン: "the"

Boyer-Moore法（簡易版）:
見つかった位置: 31 (0x7fffc200)
検索回数: 12回

通常の逐次検索:
見つかった位置: 31
検索回数: 32回

効率性向上: 62.5%
```

### 問題9-7: メモリプールの実装
大きな配列を使ったメモリプールを実装してください。

**要件:**
- 大きな char配列をメモリプールとして使用
- 以下の機能を実装:
  - 指定サイズのメモリ割り当て
  - メモリの解放
  - 使用状況の表示
  - フラグメンテーションの管理

**実装のヒント:**
- ポインタ演算でメモリブロックを管理
- 各ブロックの使用状況をヘッダで管理

**期待される出力例:**
```
=== メモリプール管理 ===
プールサイズ: 1024 バイト

メモリ割り当て:
ブロック1: 100バイト確保 (アドレス: 0x7fffc000)
ブロック2: 200バイト確保 (アドレス: 0x7fffc064)
ブロック3: 150バイト確保 (アドレス: 0x7fffc12c)

使用状況:
使用中: 450バイト (43.9%)
空き: 574バイト (56.1%)

ブロック2を解放...
フラグメンテーション発生: 3個の断片

デフラグ実行...
連続した空き領域: 774バイト
```

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex9_1.c`, `ex9_2.c` のような形式で
3. ポインタの使用を明確にコメントで説明
4. 境界チェックを忘れずに実装

## 学習のポイント
- 配列記法とポインタ記法の変換を意識
- ポインタ演算の正確な理解
- 関数への配列渡しの仕組みを完全に理解
- メモリレイアウトを常に意識して実装