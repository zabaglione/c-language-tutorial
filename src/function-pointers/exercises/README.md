# 第14章 演習問題: 関数ポインタ

## 演習の目的
- 関数ポインタの基本概念を理解する
- コールバック関数の実装方法を習得する
- 関数ポインタ配列を活用した動的関数選択を学ぶ
- 実行時関数切り替えシステムの設計を理解する

## 基礎問題

### 問題14-1: 関数ポインタの基本操作
関数ポインタを使って複数の関数を動的に呼び出すプログラムを作成してください。

**要件**

- 2つの整数を受け取り、結果を返す関数を複数定義する
- 関数ポインタを使ってこれらの関数を呼び出す
- 関数ポインタ配列を使った実装も含める

**実装すべき関数**

- `int maximum(int a, int b)` - 大きい方の値を返す
- `int minimum(int a, int b)` - 小さい方の値を返す  
- `int power(int a, int b)` - aのb乗を返す（簡単な実装で可）

**期待される出力例:**
```
=== 関数ポインタの基本操作 ===
a = 10, b = 5

関数ポインタで直接呼び出し:
maximum(10, 5) = 10
minimum(10, 5) = 5
power(10, 5) = 100000

関数ポインタ配列で呼び出し:
操作0: maximum(10, 5) = 10
操作1: minimum(10, 5) = 5
操作2: power(10, 5) = 100000

関数アドレス表示:
maximum: 0x400650
minimum: 0x400670
power: 0x400690
```

**ファイル名:** `ex14_1_basic_function_pointer.c`

### 問題14-2: 関数選択システム
文字に基づいて関数を選択し実行するシステムを実装してください。

**要件**

- 文字（'+', '-', '*', '/'など）に基づいて関数を選択
- 選択された関数を実行して結果を表示
- 無効な文字が指定された場合のエラーハンドリング
- 構造体を使った関数ポインタ管理

**期待される出力例:**
```
=== 関数選択システム ===
利用可能な演算: + - * / % ^

第1の数: 15
第2の数: 3
演算子: +
結果: 15 + 3 = 18

第1の数: 20
第2の数: 4
演算子: /
結果: 20 / 4 = 5

第1の数: 10
第2の数: 0
演算子: /
エラー: ゼロ除算はできません

第1の数: 8
第2の数: 3
演算子: @
エラー: 無効な演算子です
```

**ファイル名:** `ex14_2_function_selector.c`

## 応用問題

### 問題14-3: 配列処理のコールバック
コールバック関数を使って配列の各要素に異なる処理を適用するプログラムを作成してください。

**要件**

- 整数配列を処理する関数を複数定義
- コールバック関数として配列処理関数に渡す
- 処理前後の配列の状態を表示
- 動的な処理選択機能

**実装すべき処理**

- 各要素を倍にする
- 各要素から1を引く
- 各要素の符号を反転する

**期待される出力例:**
```
=== 配列処理のコールバック ===
元の配列: [1, 2, 3, 4, 5]

処理選択:
1. 各要素を倍にする
2. 各要素から1を引く
3. 各要素の符号を反転
選択: 1

処理後: [2, 4, 6, 8, 10]

別の配列: [5, -3, 8, -2, 0]
処理選択: 3

処理後: [-5, 3, -8, 2, 0]

複数処理の連続実行:
初期配列: [10, 20, 30]
→ 倍にする: [20, 40, 60]
→ 1を引く: [19, 39, 59]
最終結果: [19, 39, 59]
```

**ファイル名:** `ex14_3_array_callback.c`

### 問題14-4: 関数ポインタ配列を使った計算機
関数ポインタ配列を使用した計算機プログラムを作成してください。

**要件**

- 関数ポインタの配列を定義
- インデックスを指定して演算を選択
- 複数の演算を連続で実行可能
- 演算履歴を表示する機能
- 統計情報の収集と表示

**実装すべき演算**

- 加算、減算、乗算、除算
- ゼロ除算のエラーハンドリング

**期待される出力例:**
```
=== 関数ポインタ配列計算機 ===
演算メニュー:
0: 加算 (+)
1: 減算 (-)
2: 乗算 (*)
3: 除算 (/)
4: 終了

第1の数: 100
第2の数: 25
演算番号: 0
結果: 100 + 25 = 125

演算番号: 3
結果: 100 / 25 = 4

=== 演算履歴 ===
1. 100 + 25 = 125
2. 100 / 25 = 4

=== 統計情報 ===
総演算回数: 2
- 加算: 1回 (50.0%)
- 減算: 0回 (0.0%)
- 乗算: 0回 (0.0%)
- 除算: 1回 (50.0%)
```

**ファイル名:** `ex14_4_calculator_function_array.c`

## チャレンジ問題

### 問題14-5: ソートアルゴリズム選択システム
異なるソートアルゴリズムを関数ポインタで切り替えるシステムを作成してください。

**要件**

- バブルソート、選択ソート、挿入ソートを実装
- 比較関数も関数ポインタで指定（昇順/降順）
- ソート前後の配列状態を表示
- アルゴリズムの性能比較機能

**期待される出力例:**
```
=== ソートアルゴリズム選択システム ===
配列: [34, 7, 23, 32, 5, 62]

ソートアルゴリズム:
1. バブルソート
2. 選択ソート
3. 挿入ソート
選択: 1

順序:
1. 昇順
2. 降順
選択: 1

バブルソート（昇順）実行中...
結果: [5, 7, 23, 32, 34, 62]
比較回数: 15, 交換回数: 8

=== 性能比較（配列サイズ: 100） ===
アルゴリズム   比較回数  交換回数  時間(ms)
バブルソート    4950      2475      0.125
選択ソート      4950      99        0.098
挿入ソート      2525      2426      0.087
```

**ファイル名:** `ex14_5_sort_algorithms.c`

### 問題14-6: イベント駆動システム
コールバック関数を使ったイベント駆動システムを実装してください。

**要件**

- 複数種類のイベント（開始、停止、エラー、警告）
- イベントタイプごとに異なるハンドラーを登録
- イベント発生時に適切なハンドラーを呼び出し
- イベントの優先度機能

**期待される出力例:**
```
=== イベント駆動システム ===
イベントハンドラーを登録中...

イベント発生シミュレーション:

[開始] システムが起動しました
[警告] メモリ使用率が80%を超えました
[エラー] ファイルが見つかりません: config.txt
[停止] システムをシャットダウンします

優先度付きイベント処理:
優先度3: [エラー] 重大なエラーが発生
優先度1: [警告] 軽微な警告
優先度2: [開始] サービス開始

=== イベント統計 ===
開始イベント: 2回
停止イベント: 1回
エラーイベント: 2回
警告イベント: 2回
総イベント数: 7回
```

**ファイル名:** `ex14_6_event_system.c`

## 提出方法

1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex14_1.c`, `ex14_2.c` のような形式で
3. コメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認
5. C99版も作成し、`_c99.c` サフィックスを付ける

## コンパイル例

### C90準拠
```bash
gcc -std=c90 -Wall -Wextra -pedantic ex14_1_basic_function_pointer.c -o ex14_1_basic_function_pointer
```

### C99準拠
```bash
gcc -std=c99 -Wall -Wextra -pedantic ex14_1_basic_function_pointer_c99.c -o ex14_1_basic_function_pointer_c99
```

## 学習のポイント

### 関数ポインタの基本
1. **宣言**: `int (*func_ptr)(int, int);`
2. **初期化**: `func_ptr = function_name;`
3. **呼び出し**: `result = func_ptr(a, b);`
4. **配列**: `int (*operations[])(int, int) = {add, sub, mul};`

### コールバック関数
1. **概念**: 関数を引数として渡す仕組み
2. **活用**: 動的な処理選択、カスタマイズ可能な処理
3. **設計**: 関数ポインタを引数に取る関数の実装

### 実用的なテクニック
1. **関数テーブル**: 構造体による関数ポインタ管理
2. **エラーハンドリング**: 無効な関数ポインタの検出
3. **状態管理**: 関数ポインタによる状態遷移
4. **性能**: 関数ポインタ使用時のオーバーヘッド考慮

## 注意事項

- 関数ポインタは初期化前に使用しない
- 型の一致を厳密に確認する
- NULL ポインタチェックを忘れずに
- デバッグ時は関数名の確認が困難な場合がある

## 実用的な応用

これらの技術は以下のような場面で使用されます。

- **GUI フレームワーク**: イベントハンドラ
- **組み込みシステム**: 割り込みハンドラ
- **ゲーム開発**: 状態管理、AI 行動パターン
- **システムプログラミング**: プラグインシステム

## 次のステップ

この章をマスターしたら、次の章に進みましょう。
- [第13章: 高度なプログラミング技法](../advanced/)
- 関数ポインタを活用したより複雑なシステム設計
- マルチスレッドプログラミングでの関数ポインタ活用