# 演算子
## 対応C規格
- **主要対象:** C90
- **学習内容:** 算術演算子、関係演算子、論理演算子、ビット演算子、演算子の優先順位
## 学習目標
この章を完了すると、以下のことができるようになります。
- さまざまな演算子の種類と使い方を理解する
- 演算子の優先順位と結合規則を把握する
- 複雑な式を正しく記述できる
- インクリメント・デクリメント演算子を適切に使える
- ビット演算の基本を理解する
## 概要と詳細
### 演算子の世界へようこそ
プログラミングでは、数学の計算だけでなく、データの比較、条件判断、ビット操作など、様々な「演算」を行います。演算子は、これらの操作を行うための「道具」です。
電卓を使ったことがある人なら、すでに演算子を使っています。`+`、`-`、`×`、`÷`などの記号が演算子です。C言語では、これらに加えて、プログラミング特有の便利な演算子がたくさん用意されています。
この章では、C言語の演算子を一つずつ学び、それらを組み合わせて複雑な計算や判断ができるようになることを目指します。
### 算術演算子（計算の基本）
算術演算子は、日常的な計算を行うための演算子です。小学校で習った四則演算がそのまま使えます。
| 演算子 | 意味 | 例 | 結果 | 日常での例 |
|--------|------|----|----- |------------|
| `+` | 加算（足し算） | `5 + 3` | `8` | 5個のリンゴに3個追加 |
| `-` | 減算（引き算） | `5 - 3` | `2` | 5個のリンゴから3個食べる |
| `*` | 乗算（掛け算） | `5 * 3` | `15` | 5個入りの箱を3箱 |
| `/` | 除算（割り算） | `7 / 3` | `2` | 7個のお菓子を3人で分ける |
| `%` | 剰余（余り） | `7 % 3` | `1` | 7個を3人で分けた余り |
#### なぜ剰余（%）演算子が重要なのか？
剰余演算子は日常生活でも意外と使われています。
- **曜日の計算**：今日から10日後は何曜日？ → (今日の曜日 + 10) % 7
- **偶数・奇数の判定**：number % 2 が 0 なら偶数、1 なら奇数
- **時計の計算**：15時から10時間後は？ → (15 + 10) % 24 = 1時
```c
/* 偶数・奇数の判定 */
int number = 17;
if (number % 2 == 0) {
    printf("%dは偶数です\n", number);
} else {
    printf("%dは奇数です\n", number);
}
```
#### 整数除算の罠（初心者が必ず遭遇する問題）
C言語では、整数同士の割り算は「整数除算」になり、小数点以下が切り捨てられます。
```c
/* よくある間違い */
int a = 7, b = 3;
double result = a / b;        /* 期待: 2.333... 実際: 2.0 */
/* なぜ？ */
/* a / b の計算時点で整数除算（7 ÷ 3 = 2）が行われ、
   その後でdoubleに変換されるため */
/* 正しい方法1：どちらかをdoubleにキャスト */
double result = (double)a / b; /* 結果: 2.333... */
/* 正しい方法2：最初からdoubleで計算 */
double x = 7.0, y = 3.0;
double result = x / y;         /* 結果: 2.333... */
```
**覚え方のコツ**。
- 整数 ÷ 整数 = 整数（小数点以下は消える）
- 小数 ÷ 整数 = 小数（小数として計算される）
- 整数 ÷ 小数 = 小数（小数として計算される）
### 代入演算子（値を保存する）
代入演算子は、計算結果や値を変数に保存するための演算子です。`=`は数学の「等しい」ではなく、「右の値を左の変数に入れる」という意味です。
#### 基本の代入演算子
```c
int score = 85;    /* 「scoreに85を入れる」と読む */
score = 90;        /* scoreの値を90に更新 */
```
**重要な違い**。
- 数学：`x = 5` は「xは5に等しい」
- C言語：`x = 5` は「xに5を代入する（入れる）」
#### 複合代入演算子（ショートカット）
プログラミングでは、「現在の値に何かを足す/引く」という操作が頻繁に行われます。複合代入演算子はこれを簡潔に書くための便利な記法です。
| 演算子 | 意味 | 例 | 等価な記述 | 使用場面 |
|--------|------|----|-----------| ---------|
| `=` | 代入 | `a = 5` | - | 初期値設定 |
| `+=` | 加算して代入 | `a += 3` | `a = a + 3` | カウントアップ、合計計算 |
| `-=` | 減算して代入 | `a -= 2` | `a = a - 2` | カウントダウン、在庫減少 |
| `*=` | 乗算して代入 | `a *= 2` | `a = a * 2` | 倍増処理、累乗計算 |
| `/=` | 除算して代入 | `a /= 3` | `a = a / 3` | 平均値計算、分割処理 |
| `%=` | 剰余を代入 | `a %= 4` | `a = a % 4` | 循環処理、範囲制限 |
#### 実用的な使用例
```c
/* ゲームのスコア計算 */
int score = 0;
score += 100;    /* 敵を倒した：100点追加 */
score += 50;     /* アイテムゲット：50点追加 */
score -= 30;     /* ダメージを受けた：30点減少 */
printf("現在のスコア: %d\n", score);  /* 120 */
/* 在庫管理 */
int stock = 100;
stock -= 15;     /* 15個販売 */
stock += 50;     /* 50個入荷 */
printf("在庫数: %d\n", stock);  /* 135 */
/* レベルアップシステム */
int experience = 80;
experience += 40;    /* 経験値40獲得 */
if (experience >= 100) {
    printf("レベルアップ！\n");
    experience %= 100;  /* 100で割った余りが次レベルへの経験値 */
}
```
#### なぜ複合代入演算子を使うのか？
1. **コードが短くなる**
   ```c
   /* 長い書き方 */
   total_price = total_price + item_price;
   
   /* 短い書き方 */
   total_price += item_price;
   ```
2. **意図が明確になる**
   ```c
   health -= damage;    /* 「ヘルスからダメージを引く」と直感的に理解できる */
   ```
3. **タイプミスを防げる**
   ```c
   /* 変数名が長い場合、タイプミスしやすい */
   very_long_variable_name = very_long_variable_name + 1;
   
   /* こちらの方が安全 */
   very_long_variable_name += 1;
   ```
### インクリメント・デクリメント演算子（1つずつ増減）
プログラミングでは「1増やす」「1減らす」という操作が非常に多く使われます。そのため、専用の演算子が用意されています。
| 演算子 | 意味 | 前置形 | 後置形 | 使用場面 |
|--------|------|--------|--------|----------|
| `++` | 1増やす（インクリメント） | `++a` | `a++` | カウンター、ループ制御 |
| `--` | 1減らす（デクリメント） | `--a` | `a--` | カウントダウン、在庫減少 |
#### なぜこの演算子が必要なのか？
```c
/* カウンターの例（よくあるパターン） */
int count = 0;
count = count + 1;    /* 長い書き方 */
count += 1;           /* 複合代入演算子を使った書き方 */
count++;              /* 最も簡潔な書き方 */
```
ループ処理では特に頻繁に使われます。
```c
/* 10回繰り返す */
int i;
for (i = 0; i < 10; i++) {  /* i++ で毎回1増やす */
    printf("繰り返し %d 回目\n", i + 1);
}
```
#### 前置と後置の違い（重要！）
この演算子には「前置形」と「後置形」があり、微妙に動作が異なります。
```c
int a = 5, b = 5;
int x, y;
/* 前置形：先に増やしてから使う */
x = ++a;    /* ①aを6に増やす → ②xに6を代入 */
printf("x = %d, a = %d\n", x, a);  /* x = 6, a = 6 */
/* 後置形：使ってから増やす */
y = b++;    /* ①yに5を代入 → ②bを6に増やす */
printf("y = %d, b = %d\n", y, b);  /* y = 5, b = 6 */
```
#### 実用的な例で理解する
```c
/* 商品番号の発行（後置形の活用） */
int product_id = 1000;
printf("商品A: ID=%d\n", product_id++);  /* 1000を表示、その後1001に */
printf("商品B: ID=%d\n", product_id++);  /* 1001を表示、その後1002に */
printf("商品C: ID=%d\n", product_id++);  /* 1002を表示、その後1003に */
/* 在庫チェック（前置形の活用） */
int stock = 1;
if (--stock >= 0) {  /* 先に1減らして0に、その後で判定 */
    printf("在庫あり、販売可能\n");
} else {
    printf("在庫なし\n");
}
```
#### よくある間違いと対策
```c
/* 間違い例1：意図しない動作 */
int n = 5;
int result = n++ + n++;  /* 未定義動作！使ってはいけない */
/* 正しい書き方 */
int n = 5;
int result = n + (n + 1);  /* 明確に意図を表現 */
n += 2;
/* 間違い例2：条件文での使用 */
int count = 10;
if (count-- > 0) {  /* 10 > 0 を判定してからcountを9に */
    /* この時点でcountは9 */
}
/* より明確な書き方 */
int count = 10;
if (count > 0) {
    count--;
    /* 処理 */
}
```
#### 使い分けのガイドライン
- **単独で使う場合**：前置・後置どちらでも同じ
  ```c
  i++;  /* これと */
  ++i;  /* これは同じ結果 */
  ```
- **値を使いながら増減する場合**：意図に応じて選択
  ```c
  array[index++] = value;  /* 現在の位置に代入してから次へ */
  array[++index] = value;  /* 次の位置に移動してから代入 */
  ```
**C99版での詳細:** [increment_decrement_c99.c](solutions/increment_decrement_c99.c)
### 関係演算子（比較する）
関係演算子は、2つの値を比較して「正しい（真）」か「正しくない（偽）」かを判定します。日常生活での「大きい・小さい」「同じ・違う」の判断をプログラムで行うための演算子です。
#### C言語における真偽の表現
C言語では、真偽を表すために専用のブール型がありません（C99以降では`_Bool`型が追加されましたが、この章ではC90準拠のため扱いません）。代わりに、整数値を使って真偽を表現します。

- **真（True）** = 0以外の値（通常は1）
- **偽（False）** = 0

この仕組みを理解することは、条件判断を正しく書くために非常に重要です。
| 演算子 | 意味 | 例 | 結果 | 日常での例 |
|--------|------|----|----- |------------|
| `==` | 等しい | `5 == 3` | `0` (偽) | パスワードが一致するか |
| `!=` | 等しくない | `5 != 3` | `1` (真) | 在庫が0でないか |
| `<` | より小さい | `5 < 3` | `0` (偽) | 年齢が18歳未満か |
| `<=` | 以下 | `5 <= 3` | `0` (偽) | 体重が標準以下か |
| `>` | より大きい | `5 > 3` | `1` (真) | 得点が合格点より高いか |
| `>=` | 以上 | `5 >= 3` | `1` (真) | 残高が購入金額以上か |
#### 実用的な例
```c
/* パスワードチェック */
int password = 1234;
int input = 1234;
if (password == input) {
    printf("ログイン成功\n");
}
/* 在庫管理 */
int stock = 5;
if (stock > 0) {
    printf("在庫あり（%d個）\n", stock);
} else {
    printf("在庫切れ\n");
}
/* 年齢制限チェック */
int age = 16;
if (age >= 18) {
    printf("成人向けコンテンツを表示\n");
} else {
    printf("アクセス制限中\n");
}
```
#### よくある間違い：= と == の混同
```c
int x = 5;
/* 間違い：代入になってしまう */
if (x = 10) {    /* xに10を代入し、10（真）として評価 */
    printf("この部分は必ず実行される\n");
}
/* 正しい：比較 */
if (x == 10) {   /* xが10と等しいか比較 */
    printf("xは10です\n");
}
```
**覚え方のコツ**。
- `=` は「代入（入れる）」の矢印 →
- `==` は「等しいか確認」の二重チェック
### 論理演算子（条件を組み合わせる）
論理演算子は、複数の条件を組み合わせて複雑な判断を行うための演算子です。
| 演算子 | 意味 | 例 | 説明 | 日常での例 |
|--------|------|----|----- |------------|
| `&&` | かつ（AND） | `a && b` | 両方とも真なら真 | 「晴れ」かつ「暖かい」なら外出 |
| `\|\|` | または（OR） | `a \|\| b` | どちらか真なら真 | 「土曜」または「日曜」なら休み |
| `!` | でない（NOT） | `!a` | 真偽を反転 | 「雨でない」なら洗濯 |
#### 真理値表で理解する

**AND（&&）の動作**

| A | B | A && B |
|---|---|--------|
| 真 | 真 | 真 |
| 真 | 偽 | 偽 |
| 偽 | 真 | 偽 |
| 偽 | 偽 | 偽 |

**OR（||）の動作**

| A | B | A \|\| B |
|---|---|----------|
| 真 | 真 | 真 |
| 真 | 偽 | 真 |
| 偽 | 真 | 真 |
| 偽 | 偽 | 偽 |
#### 実用的な例
```c
/* 営業時間チェック（9時〜17時） */
int hour = 14;
if (hour >= 9 && hour <= 17) {
    printf("営業中です\n");
}
/* 休日判定 */
int day = 6;  /* 1=月曜...7=日曜 */
if (day == 6 || day == 7) {
    printf("週末です\n");
}
/* 割引条件（学生でない一般客） */
int is_student = 0;
if (!is_student) {
    printf("一般料金です\n");
}
/* 複雑な条件：優待条件 */
int age = 65;
int is_member = 1;
if ((age >= 65 || age < 18) && is_member) {
    printf("優待料金が適用されます\n");
}
```
#### 短絡評価（ショートサーキット）
論理演算子には「短絡評価」という重要な特性があります。これは、式の評価中に結果が確定した時点で、残りの評価をスキップする仕組みです。

##### なぜ短絡評価が重要なのか？

1. **パフォーマンスの向上** - 不要な計算を省略できる
2. **エラーの回避** - 危険な操作を安全に書ける
3. **条件付き実行** - 関数呼び出しを制御できる

##### &&（AND）の短絡評価
左側が偽（0）の場合、右側を評価しなくても全体が偽になることが確定するため、右側は評価されません。

```c
/* 基本的な例 */
int a = 0, b = 10;
if (a && b) {
    /* a が 0（偽）なので、b は評価されない */
    printf("この行は実行されない\n");
}

/* エラー回避の例：ゼロ除算を防ぐ */
int divisor = 0;
int value = 100;
if (divisor != 0 && value / divisor > 5) {
    /* divisor が 0 なので、value / divisor は計算されない */
    /* ゼロ除算エラーを回避できる！ */
    printf("結果: %d\n", value / divisor);
}

/* ポインタのNULLチェック */
char *ptr = NULL;
if (ptr != NULL && *ptr == 'A') {
    /* ptr が NULL なので、*ptr へのアクセスは行われない */
    /* セグメンテーションフォルトを回避！ */
}
```

##### ||（OR）の短絡評価
左側が真（0以外）の場合、右側を評価しなくても全体が真になることが確定するため、右側は評価されません。

```c
/* 基本的な例 */
int is_admin = 1;
int has_permission = 0;
if (is_admin || has_permission) {
    /* is_admin が 1（真）なので、has_permission は評価されない */
    printf("アクセス許可\n");
}

/* 関数呼び出しの制御 */
int cached_result = 1;
if (cached_result || expensive_calculation()) {
    /* cached_result が真なので、高コストな関数は呼ばれない */
    printf("処理を実行\n");
}

/* デフォルト値の設定 */
int user_input = 0;  /* ユーザーが何も入力しなかった */
int value = user_input || get_default_value();
/* user_input が 0 の場合のみ get_default_value() が呼ばれる */
```

##### 短絡評価を活用した実用的なテクニック

**1. 配列とポインタの安全な操作**

```c
/* 配列の境界チェック */
int array[10];
int index = 15;
if (index >= 0 && index < 10 && array[index] > 0) {
    /* index が範囲外なので、array[index] へのアクセスは行われない */
    printf("有効な値: %d\n", array[index]);
}

/* 多次元配列の安全なアクセス */
int matrix[5][5];
int row = 3, col = 7;
if (row >= 0 && row < 5 && col >= 0 && col < 5 && matrix[row][col] != 0) {
    /* 行と列の両方が範囲内の場合のみアクセス */
    process_element(matrix[row][col]);
}

/* 動的配列（ポインタ）の安全な操作 */
int *data = malloc(size * sizeof(int));
if (data && size > 0 && initialize_array(data, size)) {
    /* メモリ確保成功、かつ初期化成功の場合のみ使用 */
    use_array(data, size);
}
```

**2. 文字列処理の安全性確保**

```c
/* 文字列の安全なチェック */
char *str = get_string();  /* NULL を返す可能性がある */
if (str && strlen(str) > 0 && str[0] == 'A') {
    /* str が NULL の場合、strlen や str[0] は評価されない */
    printf("文字列は 'A' で始まります\n");
}

/* 文字列の詳細な検証 */
char *input = get_user_input();
if (input && *input && strlen(input) < MAX_LENGTH && is_valid_format(input)) {
    /* NULL でない、空でない、長さ制限内、フォーマット正しい */
    process_input(input);
}

/* 文字列の部分アクセス */
char *filename = "document.txt";
int len = strlen(filename);
if (len > 4 && filename[len-4] == '.' && strcmp(&filename[len-3], "txt") == 0) {
    /* 拡張子が .txt であることを安全に確認 */
    printf("テキストファイルです\n");
}
```

**3. ファイル操作の段階的チェック**

```c
/* ファイル操作の連鎖的エラーチェック */
FILE *fp = fopen("data.txt", "r");
if (fp && read_header(fp) && validate_data(fp)) {
    /* 各段階でエラーがあれば、後続の処理はスキップされる */
    process_file(fp);
    fclose(fp);
}

/* より詳細なファイル処理 */
char *config_file = "settings.conf";
FILE *cfg = NULL;
if ((cfg = fopen(config_file, "r")) &&
    check_file_version(cfg) &&
    load_settings(cfg) &&
    validate_settings()) {
    /* すべての段階が成功した場合のみ適用 */
    apply_settings();
    printf("設定を正常に読み込みました\n");
}
if (cfg) fclose(cfg);
```

**4. リソース管理とエラーハンドリング**

```c
/* メモリとファイルの複合的な管理 */
void process_data_file(const char *filename)
{
    FILE *fp = NULL;
    char *buffer = NULL;
    int *data = NULL;
    
    /* リソースの段階的確保 */
    if ((fp = fopen(filename, "rb")) &&
        (buffer = malloc(BUFFER_SIZE)) &&
        (data = malloc(sizeof(int) * MAX_ITEMS)) &&
        read_file_to_buffer(fp, buffer, BUFFER_SIZE) &&
        parse_buffer_to_data(buffer, data, MAX_ITEMS)) {
        
        /* すべてのリソースが正常に確保され、処理が成功 */
        analyze_data(data, MAX_ITEMS);
        
    } else {
        /* どこかでエラーが発生した */
        printf("エラー: データ処理に失敗しました\n");
    }
    
    /* クリーンアップ（NULL チェック不要） */
    free(data);
    free(buffer);
    if (fp) fclose(fp);
}
```

**5. ユーザー入力の段階的検証**

```c
/* コマンドライン引数の検証 */
int main(int argc, char *argv[])
{
    /* 引数の数と内容を段階的にチェック */
    if (argc > 1 && 
        argv[1] && 
        strlen(argv[1]) > 0 && 
        is_valid_command(argv[1])) {
        
        /* 追加の引数もチェック */
        if (argc > 2 && 
            argv[2] && 
            is_valid_parameter(argv[1], argv[2])) {
            execute_command(argv[1], argv[2]);
        } else {
            execute_command(argv[1], NULL);
        }
    } else {
        print_usage();
    }
    
    return 0;
}

/* 数値入力の検証 */
char input_buffer[100];
int value;
if (fgets(input_buffer, sizeof(input_buffer), stdin) &&
    sscanf(input_buffer, "%d", &value) == 1 &&
    value >= MIN_VALUE &&
    value <= MAX_VALUE) {
    /* 入力成功、変換成功、範囲内 */
    process_value(value);
} else {
    printf("エラー: 有効な値を入力してください\n");
}
```

**6. 条件付き処理の最適化**

```c
/* キャッシュを使った高速化 */
typedef struct {
    int is_cached;
    int cache_value;
} Cache;

int get_expensive_value(Cache *cache, int param)
{
    /* キャッシュがあればそれを使用、なければ計算 */
    if (cache && cache->is_cached && cache->cache_value) {
        return cache->cache_value;
    }
    
    /* 高コストな計算 */
    int result = expensive_calculation(param);
    
    /* キャッシュに保存 */
    if (cache) {
        cache->is_cached = 1;
        cache->cache_value = result;
    }
    
    return result;
}

/* 権限チェックの最適化 */
int can_access_resource(User *user, Resource *resource)
{
    /* 管理者は常にアクセス可能（高速パス） */
    return (user && user->is_admin) ||
           /* 一般ユーザーは詳細な権限チェック */
           (user && 
            resource && 
            user->level >= resource->required_level &&
            has_permission(user, resource->type) &&
            !is_blocked(user, resource));
}
```

##### 注意点：副作用のある式
短絡評価により、期待した副作用（変数の更新など）が発生しない場合があります。

```c
int x = 0, y = 0;

/* 注意が必要な例 */
if (x++ > 0 && y++ > 0) {
    /* x は増加するが、y は増加しない！ */
}
printf("x = %d, y = %d\n", x, y);  /* x = 1, y = 0 */

/* より明確な書き方 */
x++;
y++;
if (x > 0 && y > 0) {
    /* 意図が明確 */
}
```
#### 論理演算子の優先順位
```c
/* 括弧なしの場合（&&が||より優先） */
if (a || b && c)    /* a || (b && c) として評価 */
/* 明確にするために括弧を使う */
if ((a || b) && c)  /* 意図を明確に表現 */
```
### ビット演算子
ビットレベルで値を操作する演算子です。
| 演算子 | 意味 | 例 | 説明 |
|--------|------|----|----- |
| `&` | ビットAND | `a & b` | 対応するビットが両方1の場合1 |
| `|` | ビットOR | `a | b` | 対応するビットのいずれかが1の場合1 |
| `^` | ビットXOR | `a ^ b` | 対応するビットが異なる場合1 |
| `~` | ビット反転 | `~a` | 各ビットを反転 |
| `<<` | 左シフト | `a << 2` | ビットを左に2つシフト |
| `>>` | 右シフト | `a >> 1` | ビットを右に1つシフト |
```c
unsigned char a = 5;    /* 00000101 */
unsigned char b = 3;    /* 00000011 */
printf("a & b = %d\n", a & b);  /* 1 (00000001) */
printf("a | b = %d\n", a | b);  /* 7 (00000111) */
printf("a ^ b = %d\n", a ^ b);  /* 6 (00000110) */
printf("~a = %d\n", ~a);        /* 250 (11111010) */
```
**C99版での詳細:** [bitwise_demo_c99.c](examples/bitwise_demo_c99.c)
### 条件演算子（三項演算子）
条件に基づいて値を選択する演算子です。
```c
条件 ? 真の場合の値 : 偽の場合の値
```
```c
int a = 3, b = 7;
int max = (a > b) ? a : b;  /* b が大きいので max = 7 */
printf("大きい方: %d\n", max);
```
**C99版での詳細:** [conditional_operator_c99.c](solutions/conditional_operator_c99.c)
### sizeof演算子
データ型や変数のサイズを取得する演算子です。
```c
printf("int のサイズ: %lu バイト\n", (unsigned long)sizeof(int));
printf("double のサイズ: %lu バイト\n", (unsigned long)sizeof(double));
int arr[10];
printf("配列のサイズ: %lu バイト\n", (unsigned long)sizeof(arr));
```
### 演算子の優先順位
演算子には優先順位があり、計算の順序に影響します。
| 優先順位 | 演算子 | 結合規則 |
|----------|--------|----------|
| 1 | `()` `[]` `->` `.` | 左から右 |
| 2 | `!` `~` `++` `--` `+` `-` `*` `&` `sizeof` `(型)` | 右から左 |
| 3 | `*` `/` `%` | 左から右 |
| 4 | `+` `-` | 左から右 |
| 5 | `<<` `>>` | 左から右 |
| 6 | `<` `<=` `>` `>=` | 左から右 |
| 7 | `==` `!=` | 左から右 |
| 8 | `&` | 左から右 |
| 9 | `^` | 左から右 |
| 10 | `|` | 左から右 |
| 11 | `&&` | 左から右 |
| 12 | `||` | 左から右 |
| 13 | `?:` | 右から左 |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `|=` `<<=` `>>=` | 右から左 |
| 15 | `,` | 左から右 |
#### 優先順位の例
```c
int result = 2 + 3 * 4;     /* 結果: 14 (乗算が先) */
int result = (2 + 3) * 4;  /* 結果: 20 (括弧が先) */
```
**C99版での詳細:** [precedence_demo_c99.c](examples/precedence_demo_c99.c)
## コンパイル方法
この章では以下のMakefileを使用してコンパイルができます。
```bash
# 全ての例題をコンパイル
make all
# 特定のプログラムをコンパイル
make operators_demo
# C99版をコンパイル
make operators_demo_c99
# 全て実行
make run-all
# クリーンアップ
make clean
```
## 規格による違い
### C90での制限事項
- ビット演算子は整数型に対してのみ使用可能
- 論理演算子の結果は0または1
- ブロック先頭でのみ変数宣言可能
### C99以降の拡張
- `_Bool`型の追加により、論理値の取り扱いが明確化
- 複素数型に対する演算子の追加
- forループ内での変数宣言が可能
- インライン関数の使用が可能
## よくある間違い
### 1. 代入と比較の混同
```c
/* NG: 代入を条件文で使用 */
if (a = 5)     /* 常に真になる */
    /* ... */
/* OK: 比較演算子を使用 */
if (a == 5)    /* a が 5 と等しいかチェック */
    /* ... */
```
### 2. 整数除算の結果
```c
/* NG: 期待した結果にならない */
double result = 5 / 2;      /* 結果: 2.0 */
/* OK: 実数除算を使用 */
double result = 5.0 / 2.0;  /* 結果: 2.5 */
```
### 3. 演算子の優先順位
```c
/* NG: 意図しない計算順序 */
int result = a + b * c + d; /* b * c が先に計算される */
/* OK: 括弧で明示 */
int result = (a + b) * (c + d);
```
### 4. ビット演算の優先順位
```c
/* NG: 期待しない結果 */
if (flags & MASK == 1)      /* flags & (MASK == 1) として評価される */
/* OK: 括弧で明示 */
if ((flags & MASK) == 1)    /* 正しい評価順序 */
```
## 次の章へ
演算子と式を理解したら、[制御構造（条件分岐）](../control-if/README.md) に進んでください。
## 参考資料
- [C言語演算子リファレンス](https://ja.cppreference.com/w/c/language/operator_precedence)
- [ビット演算詳細](https://ja.cppreference.com/w/c/language/operator_arithmetic)
- [演算子優先順位表](https://ja.cppreference.com/w/c/language/operator_precedence)
## サンプルコード
### bitwise_demo.c