# 演算子

## 対応C規格

- **主要対象:** C90
- **学習内容:** 算術演算子、関係演算子、論理演算子、ビット演算子（概要）、演算子の優先順位

## 学習目標
この章を完了すると、以下のことができるようになります。

- さまざまな演算子の種類と使い方を理解する
- 演算子の優先順位と結合規則を把握する
- 複雑な式を正しく記述できる
- インクリメント・デクリメント演算子を適切に使える
- ビット演算の基本概念を理解する
- 短絡評価の基本的な動作を理解する

## 概要と詳細

### 演算子の世界へようこそ

プログラミングでは、数学の計算だけでなく、データの比較、条件判断、ビット操作など、様々な「演算」を行います。演算子は、これらの操作を行うための「道具」です。
電卓を使ったことがある人なら、すでに演算子を使っています。`+`、`-`、`×`、`÷`などの記号が演算子です。C言語では、これらに加えて、プログラミング特有の便利な演算子がたくさん用意されています。
この章では、C言語の演算子を一つずつ学び、それらを組み合わせて複雑な計算や判断ができるようになることを目指します。

### 算術演算子（計算の基本）

算術演算子は、日常的な計算を行うための演算子です。小学校で習った四則演算がそのまま使えます。

| 演算子 | 意味 | 例 | 結果 | 日常での例 |
|--------|------|----|----- |------------|
| `+` | 加算（足し算） | `5 + 3` | `8` | 5個のリンゴに3個追加 |
| `-` | 減算（引き算） | `5 - 3` | `2` | 5個のリンゴから3個食べる |
| `*` | 乗算（掛け算） | `5 * 3` | `15` | 5個入りの箱を3箱 |
| `/` | 除算（割り算） | `7 / 3` | `2` | 7個のお菓子を3人で分ける |
| `%` | 剰余（余り） | `7 % 3` | `1` | 7個を3人で分けた余り |

#### なぜ剰余（%）演算子が重要なのか？

剰余演算子は日常生活でも意外と使われています。

- **曜日の計算**：今日から10日後は何曜日？ → (今日の曜日 + 10) % 7
- **偶数・奇数の判定**：number % 2 が 0 なら偶数、1 なら奇数
- **時計の計算**：15時から10時間後は？ → (15 + 10) % 24 = 1時

```c
/* 偶数・奇数の判定 */
int number = 17;
if (number % 2 == 0) {
    printf("%dは偶数です\n", number);
} else {
    printf("%dは奇数です\n", number);
}
```

#### 整数除算の罠（初心者が必ず遭遇する問題）

C言語では、整数同士の割り算は「整数除算」になり、小数点以下が切り捨てられます。

```c
/* よくある間違い */
int a = 7, b = 3;
double result = a / b;        /* 期待: 2.333... 実際: 2.0 */

/* なぜ？ */
/* a / b の計算時点で整数除算（7 ÷ 3 = 2）が行われ、
   その後でdoubleに変換されるため */

/* 正しい方法1：どちらかをdoubleにキャスト */
double result = (double)a / b; /* 結果: 2.333... */
/* 正しい方法2：最初からdoubleで計算 */
double x = 7.0, y = 3.0;
double result = x / y;         /* 結果: 2.333... */
```

**覚え方のコツ**。

- 整数 ÷ 整数 = 整数（小数点以下は消える）
- 小数 ÷ 整数 = 小数（小数として計算される）
- 整数 ÷ 小数 = 小数（小数として計算される）

### 代入演算子（値を保存する）
代入演算子は、計算結果や値を変数に保存するための演算子です。`=`は数学の「等しい」ではなく、「右の値を左の変数に入れる」という意味です。

#### 基本の代入演算子

```c
int score = 85;    /* 「scoreに85を入れる」と読む */
score = 90;        /* scoreの値を90に更新 */
```

**重要な違い**。

- 数学：`x = 5` は「xは5に等しい」
- C言語：`x = 5` は「xに5を代入する（入れる）」

#### 複合代入演算子（ショートカット）

プログラミングでは、「現在の値に何かを足す/引く」という操作が頻繁に行われます。複合代入演算子はこれを簡潔に書くための便利な記法です。

| 演算子 | 意味 | 例 | 等価な記述 | 使用場面 |
|--------|------|----|-----------| ---------|
| `=` | 代入 | `a = 5` | - | 初期値設定 |
| `+=` | 加算して代入 | `a += 3` | `a = a + 3` | カウントアップ、合計計算 |
| `-=` | 減算して代入 | `a -= 2` | `a = a - 2` | カウントダウン、在庫減少 |
| `*=` | 乗算して代入 | `a *= 2` | `a = a * 2` | 倍増処理、累乗計算 |
| `/=` | 除算して代入 | `a /= 3` | `a = a / 3` | 平均値計算、分割処理 |
| `%=` | 剰余を代入 | `a %= 4` | `a = a % 4` | 循環処理、範囲制限 |

#### 実用的な使用例

```c
/* ゲームのスコア計算 */
int score = 0;
score += 100;    /* 敵を倒した：100点追加 */
score += 50;     /* アイテムゲット：50点追加 */
score -= 30;     /* ダメージを受けた：30点減少 */
printf("現在のスコア: %d\n", score);  /* 120 */

/* 在庫管理 */
int stock = 100;
stock -= 15;     /* 15個販売 */
stock += 50;     /* 50個入荷 */
printf("在庫数: %d\n", stock);  /* 135 */

/* レベルアップシステム */
int experience = 80;
experience += 40;    /* 経験値40獲得 */
if (experience >= 100) {
    printf("レベルアップ！\n");
    experience %= 100;  /* 100で割った余りが次レベルへの経験値 */
}
```

#### なぜ複合代入演算子を使うのか？

1. **コードが短くなる**

   ```c
   /* 長い書き方 */
   total_price = total_price + item_price;
   
   /* 短い書き方 */
   total_price += item_price;
   ```

2. **意図が明確になる**

   ```c
   health -= damage;    /* 「ヘルスからダメージを引く」と直感的に理解できる */
   ```

3. **タイプミスを防げる**

   ```c
   /* 変数名が長い場合、タイプミスしやすい */
   very_long_variable_name = very_long_variable_name + 1;
   
   /* こちらの方が安全 */
   very_long_variable_name += 1;
   ```

### インクリメント・デクリメント演算子（1つずつ増減）
プログラミングでは「1増やす」「1減らす」という操作が非常に多く使われます。そのため、専用の演算子が用意されています。

| 演算子 | 意味 | 前置形 | 後置形 | 使用場面 |
|--------|------|--------|--------|----------|
| `++` | 1増やす（インクリメント） | `++a` | `a++` | カウンター、ループ制御 |
| `--` | 1減らす（デクリメント） | `--a` | `a--` | カウントダウン、在庫減少 |

#### なぜこの演算子が必要なのか？

```c
/* カウンターの例（よくあるパターン） */
int count = 0;
count = count + 1;    /* 長い書き方 */
count += 1;           /* 複合代入演算子を使った書き方 */
count++;              /* 最も簡潔な書き方 */
```

ループ処理では特に頻繁に使われます。

```c
/* 10回繰り返す */
int i;
for (i = 0; i < 10; i++) {  /* i++ で毎回1増やす */
    printf("繰り返し %d 回目\n", i + 1);
}
```

#### 前置と後置の違い（重要！）
この演算子には「前置形」と「後置形」があり、微妙に動作が異なります。

```c
int a = 5, b = 5;
int x, y;

/* 前置形：先に増やしてから使う */
x = ++a;    /* ①aを6に増やす → ②xに6を代入 */
printf("x = %d, a = %d\n", x, a);  /* x = 6, a = 6 */

/* 後置形：使ってから増やす */
y = b++;    /* ①yに5を代入 → ②bを6に増やす */
printf("y = %d, b = %d\n", y, b);  /* y = 5, b = 6 */
```

#### 実用的な例で理解する

```c
/* 商品番号の発行（後置形の活用） */
int product_id = 1000;
printf("商品A: ID=%d\n", product_id++);  /* 1000を表示、その後1001に */
printf("商品B: ID=%d\n", product_id++);  /* 1001を表示、その後1002に */
printf("商品C: ID=%d\n", product_id++);  /* 1002を表示、その後1003に */

/* 在庫チェック（前置形の活用） */
int stock = 1;
if (--stock >= 0) {  /* 先に1減らして0に、その後で判定 */
    printf("在庫あり、販売可能\n");
} else {
    printf("在庫なし\n");
}
```

#### よくある間違いと対策
```c
/* 間違い例1：意図しない動作 */
int n = 5;
int result = n++ + n++;  /* 未定義動作！使ってはいけない */

/* 正しい書き方 */
int n = 5;
int result = n + (n + 1);  /* 明確に意図を表現 */
n += 2;

/* 間違い例2：条件文での使用 */
int count = 10;
if (count-- > 0) {  /* 10 > 0 を判定してからcountを9に */
    /* この時点でcountは9 */
}

/* より明確な書き方 */
int count = 10;
if (count > 0) {
    count--;
    /* 処理 */
}
```

#### 使い分けのガイドライン

- **単独で使う場合**：前置・後置どちらでも同じ

  ```c
  i++;  /* これと */
  ++i;  /* これは同じ結果 */
  ```

- **値を使いながら増減する場合**：意図に応じて選択

  ```c
  array[index++] = value;  /* 現在の位置に代入してから次へ */
  array[++index] = value;  /* 次の位置に移動してから代入 */
  ```

**C99版での詳細:** [increment_decrement_c99.c](solutions/increment_decrement_c99.c)

### 関係演算子（比較する）
関係演算子は、2つの値を比較して「正しい（真）」か「正しくない（偽）」かを判定します。日常生活での「大きい・小さい」「同じ・違う」の判断をプログラムで行うための演算子です。

#### C言語における真偽の表現
C言語では、真偽を表すために専用のブール型がありません（C99以降では`_Bool`型が追加されましたが、この章ではC90準拠のため扱いません）。代わりに、整数値を使って真偽を表現します。

- **真（True）** = 0以外の値（通常は1）
- **偽（False）** = 0

この仕組みを理解することは、条件判断を正しく書くために非常に重要です。

| 演算子 | 意味 | 例 | 結果 | 日常での例 |
|--------|------|----|----- |------------|
| `==` | 等しい | `5 == 3` | `0` (偽) | パスワードが一致するか |
| `!=` | 等しくない | `5 != 3` | `1` (真) | 在庫が0でないか |
| `<` | より小さい | `5 < 3` | `0` (偽) | 年齢が18歳未満か |
| `<=` | 以下 | `5 <= 3` | `0` (偽) | 体重が標準以下か |
| `>` | より大きい | `5 > 3` | `1` (真) | 得点が合格点より高いか |
| `>=` | 以上 | `5 >= 3` | `1` (真) | 残高が購入金額以上か |

#### 実用的な例

```c
/* パスワードチェック */
int password = 1234;
int input = 1234;
if (password == input) {
    printf("ログイン成功\n");
}

/* 在庫管理 */
int stock = 5;
if (stock > 0) {
    printf("在庫あり（%d個）\n", stock);
} else {
    printf("在庫切れ\n");
}

/* 年齢制限チェック */
int age = 16;
if (age >= 18) {
    printf("成人向けコンテンツを表示\n");
} else {
    printf("アクセス制限中\n");
}
```
#### よくある間違い：= と == の混同
```c
int x = 5;

/* 間違い：代入になってしまう */
if (x = 10) {    /* xに10を代入し、10（真）として評価 */
    printf("この部分は必ず実行される\n");
}

/* 正しい：比較 */
if (x == 10) {   /* xが10と等しいか比較 */
    printf("xは10です\n");
}
```

### 論理演算子（条件を組み合わせる）

論理演算子は、複数の条件を組み合わせて複雑な判断を行うための演算子です。

| 演算子 | 意味 | 例 | 説明 | 日常での例 |
|--------|------|----|----- |------------|
| && | かつ（AND） | a && b | 両方とも真なら真 | 「晴れ」かつ「暖かい」なら外出 |
| \|\| | または（OR） | a \|\| b | どちらか真なら真 | 「土曜」または「日曜」なら休み |
| ! | でない（NOT） | !a | 真偽を反転 | 「雨でない」なら洗濯 |

#### 真理値表で理解する

**AND（&&）の動作**

| A | B | A && B |
|---|---|--------|
| 真 | 真 | 真 |
| 真 | 偽 | 偽 |
| 偽 | 真 | 偽 |
| 偽 | 偽 | 偽 |

**OR（||）の動作**

| A | B | A \|\| B |
|---|---|----------|
| 真 | 真 | 真 |
| 真 | 偽 | 真 |
| 偽 | 真 | 真 |
| 偽 | 偽 | 偽 |

#### 実用的な例

```c
/* 営業時間チェック（9時〜17時） */
int hour = 14;
if (hour >= 9 && hour <= 17) {
    printf("営業中です\n");
}

/* 休日判定 */
int day = 6;  /* 1=月曜...7=日曜 */
if (day == 6 || day == 7) {
    printf("週末です\n");
}

/* 割引条件（学生でない一般客） */
int is_student = 0;
if (!is_student) {
    printf("一般料金です\n");
}

/* 複雑な条件：優待条件 */
int age = 65;
int is_member = 1;
if ((age >= 65 || age < 18) && is_member) {
    printf("優待料金が適用されます\n");
}
```

#### 短絡評価（ショートサーキット）
論理演算子には「短絡評価」という重要な特性があります。これは、式の評価中に結果が確定した時点で、残りの評価をスキップする仕組みです。

##### なぜ短絡評価が重要なのか？

1. **パフォーマンスの向上** - 不要な計算を省略できる
2. **エラーの回避** - 危険な操作を安全に書ける
3. **条件付き実行** - 関数呼び出しを制御できる

##### &&（AND）の短絡評価

左側が偽（0）の場合、右側を評価しなくても全体が偽になることが確定するため、右側は評価されません。

```c
/* 基本的な例 */
int a = 0, b = 10;
if (a && b) {
    /* a が 0（偽）なので、b は評価されない */
    printf("この行は実行されない\n");
}

/* エラー回避の例：ゼロ除算を防ぐ */
int divisor = 0;
int value = 100;
if (divisor != 0 && value / divisor > 5) {
    /* divisor が 0 なので、value / divisor は計算されない */
    /* ゼロ除算エラーを回避できる！ */
    printf("結果: %d\n", value / divisor);
}

/* ポインタのNULLチェック */
char *ptr = NULL;
if (ptr != NULL && *ptr == 'A') {
    /* ptr が NULL なので、*ptr へのアクセスは行われない */
    /* セグメンテーションフォルトを回避！ */
}
```

##### ||（OR）の短絡評価

左側が真（0以外）の場合、右側を評価しなくても全体が真になることが確定するため、右側は評価されません。

```c
/* 基本的な例 */
int is_admin = 1;
int has_permission = 0;
if (is_admin || has_permission) {
    /* is_admin が 1（真）なので、has_permission は評価されない */
    printf("アクセス許可\n");
}

/* 関数呼び出しの制御 */
int cached_result = 1;
if (cached_result || expensive_calculation()) {
    /* cached_result が真なので、高コストな関数は呼ばれない */
    printf("処理を実行\n");
}

/* デフォルト値の設定 */
int user_input = 0;  /* ユーザーが何も入力しなかった */
int value = user_input || get_default_value();
/* user_input が 0 の場合のみ get_default_value() が呼ばれる */
```

**より高度なテクニック**：短絡評価を使った安全なプログラミングパターンについては、[高度な演算子テクニック](../advanced/README.md#短絡評価による安全なプログラミング)の章を参照してください。

##### 注意点：副作用のある式
短絡評価により、期待した副作用（変数の更新など）が発生しない場合があります。

```c
int x = 0, y = 0;

/* 注意が必要な例 */
if (x++ > 0 && y++ > 0) {
    /* x は増加するが、y は増加しない！ */
}
printf("x = %d, y = %d\n", x, y);  /* x = 1, y = 0 */

/* より明確な書き方 */
x++;
y++;
if (x > 0 && y > 0) {
    /* 意図が明確 */
}
```

#### 論理演算子の優先順位

論理演算子を使用する際、最も重要なのは演算子の優先順位を理解することです。C言語では、AND演算子（`&&`）がOR演算子（`||`）よりも優先順位が高いという規則があります。この規則を理解していないと、意図しない動作を引き起こす可能性があります。

##### 基本的な優先順位規則

```c
/* 括弧なしの場合（&&が||より優先） */
if (a || b && c)    /* a || (b && c) として評価される */

/* 上記は以下と同じ意味 */
if (a || (b && c))  /* 明示的に括弧で示した場合 */

/* もし OR を先に評価したい場合は括弧が必要 */
if ((a || b) && c)  /* 意図を明確に表現 */
```

##### なぜ && が || より優先されるのか

この優先順位は、数学の掛け算が足し算より優先されるのと同じ考え方です：
- AND（`&&`）は論理的な「掛け算」（両方が真である必要がある）
- OR（`||`）は論理的な「足し算」（どちらかが真であればよい）

##### よくある間違いと正しい書き方

```c
/* 例1: ユーザーの権限チェック */
int is_admin = 0;
int is_moderator = 1;
int can_edit = 1;

/* 間違いやすい例 */
if (is_admin || is_moderator && can_edit) {
    /* 実際の評価: is_admin || (is_moderator && can_edit) */
    /* 管理者、またはモデレーターかつ編集権限がある場合 */
    printf("アクセス許可\n");
}

/* 意図が異なる場合の正しい書き方 */
if ((is_admin || is_moderator) && can_edit) {
    /* 管理者またはモデレーターで、かつ編集権限がある場合 */
    printf("アクセス許可\n");
}
```

```c
/* 例2: 数値の範囲チェック */
int x = 5, y = 15, z = 25;

/* 複雑な条件での優先順位 */
if (x < 10 || y > 20 && z < 30) {
    /* 評価順序: (x < 10) || ((y > 20) && (z < 30)) */
    /* x < 10 が真なので、全体が真 */
}

/* より明確な書き方（推奨） */
if ((x < 10) || (y > 20 && z < 30)) {
    /* 意図が一目で分かる */
}
```

##### 3つ以上の論理演算子を組み合わせる場合

```c
/* 複雑な条件式の例 */
int a = 1, b = 0, c = 1, d = 0;

/* 括弧なしの場合 */
if (a || b && c || d)
    /* 評価順序: a || (b && c) || d */
    /* 左から右へ: (a || (b && c)) || d */

/* 推奨される書き方1：意図を明確にする */
if (a || (b && c) || d) {
    /* && の優先順位を明示 */
}

/* 推奨される書き方2：複雑な条件を分割 */
int condition1 = a || d;           /* 単純な OR 条件 */
int condition2 = b && c;           /* AND 条件 */
if (condition1 || condition2) {    /* 最終的な判定 */
    /* 各条件の意味が明確 */
}
```

##### 否定演算子（!）との組み合わせ

否定演算子は論理演算子よりも優先順位が高いことに注意が必要です：

```c
/* 否定演算子の優先順位 */
if (!a && b)        /* (!a) && b として評価 */
if (!(a && b))      /* 全体を否定したい場合は括弧が必要 */

/* 実用例：ログイン状態のチェック */
int is_logged_in = 0;
int is_guest = 1;

if (!is_logged_in && !is_guest) {
    /* ログインしていない、かつゲストでもない */
    printf("アクセス拒否\n");
}

if (!(is_logged_in || is_guest)) {
    /* ログインしているか、ゲストである、のどちらでもない */
    /* 上記と同じ意味だが、ド・モルガンの法則を使用 */
    printf("アクセス拒否\n");
}
```

##### 可読性を高めるためのベストプラクティス

1. **常に括弧を使用する**
   ```c
   /* 良い例：意図が明確 */
   if ((a > 0) && (b < 10)) { }
   if ((x == 1) || (y == 2) || (z == 3)) { }
   ```

2. **複雑な条件は変数に分割する**
   ```c
   /* 複雑な条件 */
   int has_permission = (user->level >= 5) && (user->status == ACTIVE);
   int is_special_user = (user->type == ADMIN) || (user->type == MODERATOR);
   
   if (has_permission || is_special_user) {
       /* 条件の意味が明確 */
   }
   ```

3. **段階的な条件チェック**
   ```c
   /* ネストした if 文で意図を明確にする */
   if (file != NULL) {
       if (file->size > 0 && file->size < MAX_SIZE) {
           if (has_read_permission(file) || is_owner(file)) {
               /* 各段階の条件が明確 */
           }
       }
   }
   ```

##### 演算子優先順位の完全な順序

論理演算に関連する演算子の優先順位（高い順）：

1. `!` `~` `++` `--` （単項演算子）
2. `*` `/` `%` （算術演算子）
3. `+` `-` （算術演算子）
4. `<` `<=` `>` `>=` （関係演算子）
5. `==` `!=` （等価演算子）
6. `&&` （論理AND）
7. `||` （論理OR）
8. `?:` （条件演算子）
9. `=` `+=` `-=` など（代入演算子）

この優先順位を覚えることも重要ですが、実際のコードでは括弧を使って意図を明確にすることがより重要です。
### ビット演算子（概要）

ビット演算子は、数値をビット（0と1）のレベルで直接操作する演算子です。ここでは基本的な演算子の一覧のみを示します。

#### ビット演算子の種類

| 演算子 | 意味 | 例 | 説明 |
|--------|------|----|----- |
| & | ビットAND | a & b | 対応するビットが両方1の場合1 |
| \| | ビットOR | a \| b | 対応するビットのいずれかが1の場合1 |
| ^ | ビットXOR | a ^ b | 対応するビットが異なる場合1 |
| ~ | ビット反転 | ~a | 各ビットを反転（0→1、1→0） |
| << | 左シフト | a << 2 | ビットを左に2つシフト |
| >> | 右シフト | a >> 1 | ビットを右に1つシフト |

#### 基本的な例

```c
unsigned char a = 5;    /* 00000101 (2進数) */
unsigned char b = 3;    /* 00000011 (2進数) */

printf("a & b = %d\n", a & b);  /* 1 (00000001) */
printf("a | b = %d\n", a | b);  /* 7 (00000111) */
printf("a ^ b = %d\n", a ^ b);  /* 6 (00000110) */
printf("~a = %d\n", (unsigned char)~a);  /* 250 (11111010) */
```

#### 注意点

- ビット演算子は比較演算子より優先順位が低いので括弧に注意
- 符号付き整数の右シフトは実装依存

**詳細な学習**: ビット演算の詳細、ビットマスク、ビットフィールド、実践的な活用方法については、[第12章: ビット操作とビットフィールド](../bit-operations/README.md)で詳しく説明しています。

### 条件演算子（三項演算子）
条件に基づいて値を選択する演算子です。

```c
条件 ? 真の場合の値 : 偽の場合の値
```

```c
int a = 3, b = 7;
int max = (a > b) ? a : b;  /* b が大きいので max = 7 */
printf("大きい方: %d\n", max);
```

**C99版での詳細:** [conditional_operator_c99.c](solutions/conditional_operator_c99.c)

### sizeof演算子
データ型や変数のサイズを取得する演算子です。

```c
printf("int のサイズ: %lu バイト\n", (unsigned long)sizeof(int));
printf("double のサイズ: %lu バイト\n", (unsigned long)sizeof(double));
int arr[10];
printf("配列のサイズ: %lu バイト\n", (unsigned long)sizeof(arr));
```

### 演算子の優先順位

演算子には優先順位があり、計算の順序に影響します。

| 優先順位 | 演算子 | 結合規則 |
|----------|--------|----------|
| 1 | `()` `[]` `->` `.` | 左から右 |
| 2 | `!` `~` `++` `--` `+` `-` `*` `&` `sizeof` `(型)` | 右から左 |
| 3 | `*` `/` `%` | 左から右 |
| 4 | `+` `-` | 左から右 |
| 5 | `<<` `>>` | 左から右 |
| 6 | `<` `<=` `>` `>=` | 左から右 |
| 7 | `==` `!=` | 左から右 |
| 8 | `&` | 左から右 |
| 9 | `^` | 左から右 |
| 10 | `\|` | 左から右 |
| 11 | `&&` | 左から右 |
| 12 | `\|\|` | 左から右 |
| 13 | `?:` | 右から左 |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `\|=` `<<=` `>>=` | 右から左 |
| 15 | `,` | 左から右 |

#### 優先順位の例

```c
int result = 2 + 3 * 4;     /* 結果: 14 (乗算が先) */
int result = (2 + 3) * 4;  /* 結果: 20 (括弧が先) */
```

**C99版での詳細:** [precedence_demo_c99.c](examples/precedence_demo_c99.c)

## コンパイル方法
この章では以下のMakefileを使用してコンパイルができます。

```bash
# 全ての例題をコンパイル
make all
# 特定のプログラムをコンパイル
make operators_demo
# C99版をコンパイル
make operators_demo_c99
# 全て実行
make run-all
# クリーンアップ
make clean
```

## 規格による違い

### C90での制限事項
- ビット演算子は整数型に対してのみ使用可能
- 論理演算子の結果は0または1
- ブロック先頭でのみ変数宣言可能

### C99以降の拡張
- `_Bool`型の追加により、論理値の取り扱いが明確化
- 複素数型に対する演算子の追加
- forループ内での変数宣言が可能
- インライン関数の使用が可能

## よくある間違い

### 1. 代入と比較の混同

```c
/* NG: 代入を条件文で使用 */
if (a = 5)     /* 常に真になる */
    /* ... */
/* OK: 比較演算子を使用 */
if (a == 5)    /* a が 5 と等しいかチェック */
    /* ... */
```

### 2. 整数除算の結果

```c
/* NG: 期待した結果にならない */
double result = 5 / 2;      /* 結果: 2.0 */
/* OK: 実数除算を使用 */
double result = 5.0 / 2.0;  /* 結果: 2.5 */
```

### 3. 演算子の優先順位

```c
/* NG: 意図しない計算順序 */
int result = a + b * c + d; /* b * c が先に計算される */
/* OK: 括弧で明示 */
int result = (a + b) * (c + d);
```

### 4. ビット演算の優先順位

```c
/* NG: 期待しない結果 */
if (flags & MASK == 1)      /* flags & (MASK == 1) として評価される */
/* OK: 括弧で明示 */
if ((flags & MASK) == 1)    /* 正しい評価順序 */
```

## 次の章へ
演算子と式を理解したら、[制御構造（条件分岐）](../control-if/README.md) に進んでください。

## 参考資料
- [C言語演算子リファレンス](https://ja.cppreference.com/w/c/language/operator_precedence)
- [ビット演算詳細](https://ja.cppreference.com/w/c/language/operator_arithmetic)
- [演算子優先順位表](https://ja.cppreference.com/w/c/language/operator_precedence)
