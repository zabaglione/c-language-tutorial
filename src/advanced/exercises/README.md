# 第15章 演習問題: 高度なトピック

## 演習の目的
- プリプロセッサの高度な使い方を習得する
- メモリ管理の最適化技術を学ぶ
- キャッシュ効率を考慮したプログラミングを理解する
- システムプログラミングの基礎を身につける

## 基礎問題

### 問題15-1: プリプロセッサマクロの基本
以下の仕様を満たすプログラムを作成してください。

**要件**

- 数学的な定数をマクロで定義する（PI、E、黄金比など）
- 基本的な計算マクロを定義する（面積、体積など）
- 条件付きコンパイルでデバッグ機能を切り替える
- 文字列化マクロと連結マクロを活用する

**実装すべき機能**

- 円の面積・周長計算
- 球の体積・表面積計算
- デバッグ情報の出力（条件付き）
- マクロによる型安全な最大値・最小値関数

**期待される出力例:**
```
=== プリプロセッサマクロの基本 ===
円の計算（半径 = 5.0）:
- 面積: 78.54
- 周長: 31.42

球の計算（半径 = 3.0）:
- 体積: 113.10
- 表面積: 113.10

[DEBUG] 計算完了: 円の面積 = 78.54 (半径: 5.0)
[DEBUG] 計算完了: 球の体積 = 113.10 (半径: 3.0)

型安全な最大値・最小値:
MAX(10, 20) = 20
MIN(3.14, 2.71) = 2.71

黄金比を使った計算:
黄金長方形 (短辺 = 10): 長辺 = 16.18
```

**ファイル名:** `ex15_1_macro_basics.c`

### 問題15-2: 安全なメモリ操作マクロ
メモリ操作の安全性を向上させるマクロ群を作成してください。

**要件**

- NULL チェック付きメモリ割り当て
- 配列境界チェック付きアクセス
- 自動的なメモリ解放
- メモリリーク検出機能

**実装すべきマクロ**

- `SAFE_MALLOC(size)` - NULLチェック付きmalloc
- `SAFE_FREE(ptr)` - NULLクリア付きfree
- `ARRAY_BOUNDS_CHECK(arr, index, size)` - 境界チェック
- `MEMORY_LEAK_TRACKER` - 簡単なリーク検出

**期待される出力例:**
```
=== 安全なメモリ操作マクロ ===

通常のメモリ割り当て:
100バイトを割り当て: 成功 (0x7fff5fbff8c0)
解放完了（ポインタはNULLにリセット）

メモリ不足シミュレーション:
SAFE_MALLOC失敗: メモリ割り当てエラー (行: 45)

配列境界チェック:
配列[0-9]へのアクセステスト:
index 5: OK (値: 50)
index 10: エラー - 境界外アクセス検出！ (行: 67)

=== メモリリーク検出レポート ===
総割り当て: 1024 バイト
総解放: 768 バイト
リーク検出: 256 バイト (1ブロック)
  - ブロック#3: 256バイト (行: 89で割り当て)
```

**ファイル名:** `ex15_2_safe_memory.c`

### 問題15-3: 基本的なメモリプール
固定サイズオブジェクト用の簡単なメモリプールを実装してください。

**要件**

- 事前に確保されたメモリ領域からオブジェクトを割り当て
- フリーリストによる高速な割り当て・解放
- プールの使用状況を表示する機能
- 初期化・終了処理

**実装すべき機能**

- プールの初期化と終了処理
- オブジェクトの取得と返却
- 使用状況の表示
- エラーハンドリング

**期待される出力例:**
```
=== 基本的なメモリプール ===
プール初期化: 100個のオブジェクト（各64バイト）

10個のオブジェクトを割り当て...
割り当て成功: 10個

=== プール使用状況 ===
総容量: 100 オブジェクト
使用中: 10 オブジェクト (10.0%)
空き: 90 オブジェクト (90.0%)
総メモリ: 6400 バイト

5個のオブジェクトを返却...

=== 更新後の使用状況 ===
使用中: 5 オブジェクト (5.0%)
空き: 95 オブジェクト (95.0%)

パフォーマンステスト（1000回の割り当て/解放）:
- メモリプール: 0.15ms
- 通常のmalloc/free: 2.34ms
- 高速化: 15.6倍
```

**ファイル名:** `ex15_3_memory_pool.c`

## 応用問題

### 問題15-4: 汎用的なプリプロセッサライブラリ
さまざまな用途に使える汎用的なマクロライブラリを作成してください。

**要件**

- 型判定マクロ（コンパイル時）
- 汎用的なスワップマクロ
- ループ展開マクロ
- アサーション機能付きマクロ
- ベンチマーク計測マクロ

**実装すべき機能**

- `TYPE_CHECK(a, b)` - 型の一致確認
- `GENERIC_SWAP(a, b)` - 任意の型のスワップ
- `REPEAT(n, code)` - コードの繰り返し展開
- `BENCHMARK_BLOCK(name)` - ブロックの実行時間測定
- `STATIC_ASSERT(condition, message)` - コンパイル時アサーション

**期待される出力例:**
```
=== 汎用的なプリプロセッサライブラリ ===

型チェック:
TYPE_CHECK(int, int): OK
TYPE_CHECK(int, double): 型不一致（コンパイル時警告）

汎用スワップ:
整数: a=10, b=20 → a=20, b=10
文字列: s1="Hello", s2="World" → s1="World", s2="Hello"
構造体: p1=(1,2), p2=(3,4) → p1=(3,4), p2=(1,2)

ループ展開（5回）:
展開0: i=0, value=0
展開1: i=1, value=1
展開2: i=2, value=4
展開3: i=3, value=9
展開4: i=4, value=16

=== ベンチマーク結果 ===
[BENCHMARK] 配列初期化: 0.234ms
[BENCHMARK] 行列演算: 1.567ms
[BENCHMARK] ソート処理: 3.890ms

スタティックアサート:
コンパイル時チェック: すべてOK
```

**ファイル名:** `ex15_4_generic_macros.c`

### 問題15-5: 高性能メモリアロケーター
パフォーマンスを重視したカスタムメモリアロケーターを実装してください。

**要件**

- サイズ別メモリプール（小・中・大オブジェクト）
- メモリの断片化を最小限に抑える仕組み
- アロケーション統計情報の収集
- スレッドセーフ対応（簡易版）

**実装すべき機能**

- 複数サイズのメモリプール管理
- First Fit / Best Fit アルゴリズム
- メモリ使用統計とレポート機能
- デバッグモードでの詳細トレース

**期待される出力例:**
```
=== 高性能メモリアロケーター ===

アロケーターを初期化中...
- 小オブジェクトプール: 0-64 バイト
- 中オブジェクトプール: 65-512 バイト
- 大オブジェクトプール: 513+ バイト

割り当てテスト:
32バイト割り当て: 成功 (小プールから)
256バイト割り当て: 成功 (中プールから)
1024バイト割り当て: 成功 (大プールから)

=== メモリ使用統計 ===
小オブジェクトプール:
  割り当て回数: 150
  解放回数: 120
  現在使用中: 30 (1920 バイト)
  断片化率: 5.2%

中オブジェクトプール:
  割り当て回数: 50
  解放回数: 45
  現在使用中: 5 (1280 バイト)
  断片化率: 8.7%

大オブジェクトプール:
  割り当て回数: 10
  解放回数: 8
  現在使用中: 2 (2048 バイト)
  断片化率: 12.3%

総メモリ使用量: 5248 バイト
平均割り当て時間: 0.0034ms
```

**ファイル名:** `ex15_5_allocator.c`

## チャレンジ問題

### 問題15-6: キャッシュフレンドリーなデータ構造
CPU キャッシュ効率を考慮したデータ構造を実装してください。

**要件**

- 配列ベースの動的配列（vector 風）
- キャッシュラインを意識したメモリレイアウト
- プリフェッチを活用した高速アクセス
- メモリプールとの連携

**実装すべき機能**

- 動的な要素追加・削除
- キャッシュ効率的な反復処理
- バルク操作（一括挿入・削除）
- パフォーマンス測定機能

**期待される出力例:**
```
=== キャッシュフレンドリーなデータ構造 ===

ベクター初期化（初期容量: 16）
キャッシュライン境界でアラインメント済み

要素追加テスト:
1000要素を追加中...
容量自動拡張: 16 → 32 → 64 → 128 → 256 → 512 → 1024

=== パフォーマンス比較 ===
順次アクセス（キャッシュ効率的）:
- キャッシュベクター: 0.089ms
- 通常の配列: 0.156ms
- 高速化: 1.75倍

ランダムアクセス:
- キャッシュベクター: 0.234ms
- 通常の配列: 0.312ms
- 高速化: 1.33倍

バルク操作（100要素一括挿入）:
- キャッシュベクター: 0.012ms
- 個別挿入: 0.089ms
- 高速化: 7.42倍

=== キャッシュ統計 ===
L1キャッシュヒット率: 94.3%
L2キャッシュヒット率: 98.7%
プリフェッチ効果: 23.4%の改善
```

**ファイル名:** `ex15_6_cache_vector.c`

### 問題15-7: プリプロセッサベースのDSL
プリプロセッサを使ってドメイン固有言語（DSL）を作成してください。

**要件**

- 状態機械を記述するDSL
- イベント駆動システムの記述
- 自動的なコード生成
- コンパイル時検証機能

**実装例:**
```c
STATE_MACHINE(TrafficLight)
    STATE(Red)    TIMEOUT() -> Yellow
    STATE(Yellow) TIMEOUT() -> Green  
    STATE(Green)  TIMEOUT() -> Red
END_STATE_MACHINE
```

**期待される出力例:**
```
=== プリプロセッサベースのDSL ===

信号機状態機械の定義:
状態数: 3
遷移数: 3

状態機械を実行中...
[00:00] 状態: Red
[00:05] タイムアウト → Yellow へ遷移
[00:06] 状態: Yellow
[00:08] タイムアウト → Green へ遷移
[00:09] 状態: Green
[00:14] タイムアウト → Red へ遷移
[00:15] 状態: Red

=== コード生成結果 ===
生成された関数:
- void TrafficLight_init()
- void TrafficLight_process_event(Event)
- State TrafficLight_get_state()
- const char* TrafficLight_state_name(State)

生成されたコード行数: 87行
マクロ展開前: 12行
圧縮率: 7.25倍

=== 検証結果 ===
✓ すべての状態から遷移可能
✓ デッドロックなし
✓ 未定義遷移なし
```

**ファイル名:** `ex15_7_dsl.c`

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex15_1.c`, `ex15_2.c` のような形式で
3. 高度な機能を使う場合は、その意図をコメントで説明
4. パフォーマンス測定結果も含める

## 学習のポイント
- プリプロセッサは強力だが、使いすぎると可読性が低下する
- メモリ管理は性能に直結する重要な要素
- キャッシュ効率を考慮すると大幅な性能向上が可能
- システムレベルの知識が高度なC言語プログラミングには不可欠