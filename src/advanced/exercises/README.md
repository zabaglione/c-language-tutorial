# 演習課題：高度なトピック

## 基礎課題

### 演習13-1: プリプロセッサマクロの基本
以下の仕様を満たすプログラムを作成してください。

**仕様：**
- 数学的な定数をマクロで定義する（PI、E、黄金比など）
- 基本的な計算マクロを定義する（面積、体積など）
- 条件付きコンパイルでデバッグ機能を切り替える
- 文字列化マクロと連結マクロを活用する

**実装すべき機能：**
- 円の面積・周長計算
- 球の体積・表面積計算
- デバッグ情報の出力（条件付き）
- マクロによる型安全な最大値・最小値関数

**ファイル名：** `ex13_1_macro_basics.c`

### 演習13-2: 安全なメモリ操作マクロ
メモリ操作の安全性を向上させるマクロ群を作成してください。

**仕様：**
- NULL チェック付きメモリ割り当て
- 配列境界チェック付きアクセス
- 自動的なメモリ解放
- メモリリーク検出機能

**実装すべきマクロ：**
- `SAFE_MALLOC(size)` - NULLチェック付きmalloc
- `SAFE_FREE(ptr)` - NULLクリア付きfree
- `ARRAY_BOUNDS_CHECK(arr, index, size)` - 境界チェック
- `MEMORY_LEAK_TRACKER` - 簡単なリーク検出

**ファイル名：** `ex13_2_safe_memory.c`

### 演習13-3: 基本的なメモリプール
固定サイズオブジェクト用の簡単なメモリプールを実装してください。

**仕様：**
- 事前に確保されたメモリ領域からオブジェクトを割り当て
- フリーリストによる高速な割り当て・解放
- プールの使用状況を表示する機能
- 初期化・終了処理

**実装すべき機能：**
- プールの初期化と終了処理
- オブジェクトの取得と返却
- 使用状況の表示
- エラーハンドリング

**ファイル名：** `ex13_3_memory_pool.c`

## 応用課題

### 演習13-4: 汎用的なプリプロセッサライブラリ
さまざまな用途に使える汎用的なマクロライブラリを作成してください。

**仕様：**
- 型判定マクロ（コンパイル時）
- 汎用的なスワップマクロ
- ループ展開マクロ
- アサーション機能付きマクロ
- ベンチマーク計測マクロ

**実装すべき機能：**
- `TYPE_CHECK(a, b)` - 型の一致確認
- `GENERIC_SWAP(a, b)` - 任意の型のスワップ
- `REPEAT(n, code)` - コードの繰り返し展開
- `BENCHMARK_BLOCK(name)` - ブロックの実行時間測定
- `STATIC_ASSERT(condition, message)` - コンパイル時アサーション

**ファイル名：** `ex13_4_generic_macros.c`

### 演習13-5: 高性能メモリアロケーター
パフォーマンスを重視したカスタムメモリアロケーターを実装してください。

**仕様：**
- サイズ別メモリプール（小・中・大オブジェクト）
- メモリの断片化を最小限に抑える仕組み
- アロケーション統計情報の収集
- スレッドセーフ対応（簡易版）

**実装すべき機能：**
- 複数サイズのメモリプール管理
- First Fit / Best Fit アルゴリズム
- メモリ使用統計とレポート機能
- デバッグモードでの詳細トレース

**ファイル名：** `ex13_5_allocator.c`

### 演習13-6: キャッシュフレンドリーなデータ構造
CPU キャッシュ効率を考慮したデータ構造を実装してください。

**仕様：**
- 配列ベースの動的配列（vector 風）
- キャッシュラインを意識したメモリレイアウト
- プリフェッチを活用した高速アクセス
- メモリプールとの連携

**実装すべき機能：**
- 動的な要素追加・削除
- キャッシュ効率的な反復処理
- バルク操作（一括挿入・削除）
- パフォーマンス測定機能

**ファイル名：** `ex13_6_cache_vector.c`

## 挑戦課題

### 演習13-7: プリプロセッサベースのDSL
プリプロセッサを使ってドメイン固有言語（DSL）を作成してください。

**仕様：**
- 状態機械を記述するDSL
- イベント駆動システムの記述
- 自動的なコード生成
- コンパイル時検証機能

**実装例：**
```c
STATE_MACHINE(TrafficLight)
    STATE(Red)    TIMEOUT() -> Yellow
    STATE(Yellow) TIMEOUT() -> Green  
    STATE(Green)  TIMEOUT() -> Red
END_STATE_MACHINE

EVENT_HANDLER(ButtonPress) 
    // イベント処理コード
END_EVENT_HANDLER
```

**ファイル名：** `ex13_7_dsl.c`

### 演習13-8: 動的メモリ管理フレームワーク
ガベージコレクション機能付きのメモリ管理フレームワークを実装してください。

**仕様：**
- 参照カウント式ガベージコレクション
- 循環参照の検出と解決
- 弱参照（weak reference）のサポート
- メモリプレッシャー対応

**実装すべき機能：**
- オブジェクトの自動管理
- 参照カウントの増減
- 循環参照のマーク&スイープ
- メモリ不足時の自動解放

**ファイル名：** `ex13_8_gc_framework.c`

### 演習13-9: リアルタイムメモリアロケーター
リアルタイムシステム向けの決定的メモリアロケーターを実装してください。

**仕様：**
- O(1) での割り当て・解放保証
- メモリ断片化の完全排除
- 予測可能なメモリ使用量
- 割り込み処理からの安全な使用

**実装すべき機能：**
- 固定時間でのメモリ操作
- 事前確保によるメモリプール
- 優先度別メモリ管理
- リアルタイム統計情報

**ファイル名：** `ex13_9_realtime.c`

## 評価基準

### 基礎課題（各10点）
- 正しく動作する：5点
- コードの可読性：3点
- エラーハンドリング：2点

### 応用課題（各15点）
- 機能の完全性：5点
- パフォーマンス：4点
- 設計の優秀さ：3点
- 拡張性：3点

### 挑戦課題（各20点）
- 実装の完成度：8点
- 創意工夫：5点
- 技術的難易度：4点
- 実用性：3点

## 提出方法

1. 各課題を指定されたファイル名で作成
2. コンパイル用のMakefileを作成
3. 実行例とパフォーマンス結果を含むREADME.mdを作成
4. すべてのファイルを`solutions/`フォルダーに配置

## 学習のポイント

### プリプロセッサの活用
- マクロの安全な使用方法
- 条件付きコンパイルの効果的な活用
- コード生成の自動化
- デバッグ支援機能

### メモリ管理の最適化
- メモリプールの設計と実装
- キャッシュ効率を考慮したデータ構造
- パフォーマンス測定と改善
- メモリリークの検出と防止

### 高度なC言語技法
- 型安全なプログラミング
- コンパイル時計算の活用
- ハードウェア特性を考慮した実装
- システムプログラミング技法

## 参考資料

### プリプロセッサ高度技法
```c
// X-マクロパターン
#define COLORS \
    X(RED, "赤") \
    X(GREEN, "緑") \
    X(BLUE, "青")

typedef enum {
#define X(name, desc) COLOR_##name,
    COLORS
#undef X
    COLOR_COUNT
} Color;

const char* color_names[] = {
#define X(name, desc) desc,
    COLORS
#undef X
};
```

### メモリアライメント最適化
```c
// キャッシュライン境界でのアライメント
#define CACHE_LINE_SIZE 64
#define CACHE_ALIGNED __attribute__((aligned(CACHE_LINE_SIZE)))

typedef struct CACHE_ALIGNED {
    int frequently_accessed_data;
    char padding[CACHE_LINE_SIZE - sizeof(int)];
} CacheOptimizedStruct;
```

### 高性能メモリ操作
```c
// SIMD命令を使った高速メモリコピー
#include <immintrin.h>

void fast_memcpy(void* dst, const void* src, size_t size) {
    // AVXを使った実装例
    if (size >= 32 && ((intptr_t)dst & 31) == 0 && ((intptr_t)src & 31) == 0) {
        // 32バイト境界でアラインされている場合の最適化
    }
}
```

## よくある間違いとその対策

### 1. マクロの副作用
**間違い：**
```c
#define SQUARE(x) x * x
int a = 5;
int result = SQUARE(++a);  // a が2回インクリメントされる
```

**正解：**
```c
#define SQUARE(x) ({ \
    typeof(x) _temp = (x); \
    _temp * _temp; \
})
```

### 2. メモリアライメントの無視
**間違い：**
```c
char buffer[100];
int* ptr = (int*)&buffer[1];  // 不正なアライメント
```

**正解：**
```c
#include <stdalign.h>
alignas(int) char buffer[100];
int* ptr = (int*)buffer;
```

### 3. キャッシュ効率の無視
**間違い：**
```c
// 列優先アクセス（キャッシュミスが多発）
for (int j = 0; j < cols; j++) {
    for (int i = 0; i < rows; i++) {
        matrix[i][j] = value;
    }
}
```

**正解：**
```c
// 行優先アクセス（キャッシュフレンドリー）
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = value;
    }
}
```

これらの課題を通じて、C言語の高度な機能を習得し、パフォーマンスを意識したプログラミングスキルを身につけてください。