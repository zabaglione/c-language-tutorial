# 第12章: 関数ポインタ - 演習解答例

このディレクトリには、第12章の演習問題の解答例が含まれています。各解答例はC90標準準拠版とC99版の両方を提供し、すべて非対話型のデモ版として実装されています。

## 解答例一覧

### 演習12-1: 関数ポインタの基本操作
- **C90版**: [ex12_1_basic_function_pointer.c](ex12_1_basic_function_pointer.c)
- **C99版**: [ex12_1_basic_function_pointer_c99.c](ex12_1_basic_function_pointer_c99.c)
- **内容**: 関数ポインタを使った動的関数呼び出しのデモ（maximum, minimum, power関数）
- **学習ポイント**: 関数ポインタの宣言、初期化、呼び出し、配列での管理

### 演習12-2: 関数選択システム
- **C90版**: [ex12_2_function_selector.c](ex12_2_function_selector.c)
- **C99版**: [ex12_2_function_selector_c99.c](ex12_2_function_selector_c99.c)
- **内容**: 文字に基づく関数選択システム（構造体による関数ポインタ管理）
- **学習ポイント**: 構造体と関数ポインタの組み合わせ、エラーハンドリング

### 演習12-3: 配列処理のコールバック
- **C90版**: [ex12_3_array_callback.c](ex12_3_array_callback.c)
- **C99版**: [ex12_3_array_callback_c99.c](ex12_3_array_callback_c99.c)
- **内容**: コールバック関数を使った配列要素処理（倍加、減算、符号反転）
- **学習ポイント**: コールバック関数の概念、関数ポインタを引数として渡す方法

### 演習12-4: 関数ポインタ配列を使った計算機
- **C90版**: [ex12_4_calculator_function_array.c](ex12_4_calculator_function_array.c)
- **C99版**: [ex12_4_calculator_function_array_c99.c](ex12_4_calculator_function_array_c99.c)
- **内容**: 関数ポインタ配列による計算機（履歴管理、統計機能付き）
- **学習ポイント**: 関数ポインタ配列、履歴管理、連続計算

## 実装上の特徴

### 非対話型デモ版について
すべての解答例は、クラッシュを避けるため scanf() による対話型入力を排除し、予め定義された値を使用するデモ版として実装されています。

### 教育的配慮
- 各ファイルには詳細なコメントと学習ポイントを記載
- C90とC99の違いを明確に示すコード例
- 実用的な応用例を含むデモンストレーション

### セキュリティ対策
- ゼロ除算エラーのハンドリング
- 配列境界の適切なチェック
- 無効な関数ポインタの検出

## C90版とC99版の主な違い

### C90版の特徴
- 変数宣言は関数やブロックの先頭で行う
- `/* */` 形式のコメントのみ使用
- for文の初期化部で変数宣言不可
- bool型は独自定義または整数型で代替

### C99版の特徴
- 変数宣言を使用箇所で可能
- `//` 形式のコメントも使用可能
- for文内での変数宣言が可能
- `<stdbool.h>`のbool型を使用
- 指定初期化子による構造体初期化
- 可変長配列（VLA）のサポート

## コンパイル方法

### C90版のコンパイル
```bash
gcc -Wall -Wextra -pedantic -std=c90 -o program_name source_file.c
```

### C99版のコンパイル
```bash
gcc -Wall -Wextra -pedantic -std=c99 -o program_name source_file_c99.c
```

## 学習のポイント

1. **関数ポインターの基本**
   - 関数ポインターの宣言方法
   - 関数アドレスの取得と呼び出し
   - 関数ポインターの型定義（typedef）

2. **関数ポインターの応用**
   - コールバック関数の実装
   - 関数ポインター配列の活用
   - 動的な関数選択

3. **設計パターン**
   - イベント駆動プログラミング
   - プラグインアーキテクチャ
   - 状態マシンパターン

4. **実践的な活用**
   - エラーハンドリング
   - 拡張性の高い設計
   - 保守性を考慮したコード構造

## 注意事項

- これらの解答例は一つの実装方法を示したものです
- 実際の開発では、要件に応じて適切な実装を選択してください
- エラーハンドリングは基本的なレベルに留めています
- メモリ管理が必要な場合は、適切な解放処理を追加してください