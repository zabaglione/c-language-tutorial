---
title: "C言語プログラミング教材 - 演習問題集（上級編）"
subtitle: "第12章〜第16章の演習問題"
author: "C言語学習教材プロジェクト"
date: "2024年"
documentclass: report
lang: ja
fontsize: 12pt
geometry: margin=1in
toc: true
toc-depth: 2
numbersections: true
---

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```

# はじめに

本書は、C言語プログラミング教材上級編の演習問題集です。ビット操作、構造体、関数ポインタなど、実務で必要となる高度な技術を実践的に習得するための問題を収録しています。

## 前提知識

上級編の演習問題に取り組む前に、以下の内容を完全に理解していることが必要です：

- ポインタと配列の関係
- 動的メモリ管理
- 関数の設計と実装
- 文字列処理

## 演習問題の特徴

上級編の演習問題は、実務で遭遇する実際の課題に基づいています：

- **システムプログラミング**: ハードウェアに近いレベルの処理
- **データ構造**: 効率的なデータ管理手法
- **設計パターン**: 再利用可能なコード設計

## チャレンジ問題

各章には「チャレンジ問題」が含まれています。これらは発展的な内容で、より深い理解と創造性が求められます。

---


```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第12章: ビット操作とビットフィールド - 演習問題


## 演習問題の目的
この章では、ビット演算子の使い方、ビットマスクによるフラグ管理、ビットフィールドの活用、そして実践的なビット操作技術を習得します。

## 演習 12-1: 基本的なビット操作
**難易度:** ★☆☆

以下の処理を行う関数を実装してください：

1. 整数の特定ビットをセット/クリア/反転する関数
2. 整数の特定範囲のビットを抽出する関数
3. 整数のビットを左右に循環シフトする関数

```c
/* 実装すべき関数のプロトタイプ */
void set_bit(unsigned int *value, int bit);
void clear_bit(unsigned int *value, int bit);
void toggle_bit(unsigned int *value, int bit);
int test_bit(unsigned int value, int bit);

unsigned int extract_bits(unsigned int value, int start, int count);
unsigned int rotate_left(unsigned int value, int shift);
unsigned int rotate_right(unsigned int value, int shift);
```

**要件:**
- ビット位置は0から31まで
- 範囲外のビット位置の場合は何もしない
- 循環シフトは32ビットの範囲で行う

## 演習 12-2: フラグ管理システム
**難易度:** ★★☆

ゲームキャラクターの状態を管理するフラグシステムを実装してください：

```c
/* 状態フラグの定義 */
#define STATUS_ALIVE     0x0001
#define STATUS_POISONED  0x0002
#define STATUS_PARALYZED 0x0004
#define STATUS_CONFUSED  0x0008
#define STATUS_SLEEPING  0x0010
#define STATUS_BURNING   0x0020
#define STATUS_FROZEN    0x0040
#define STATUS_INVISIBLE 0x0080
#define STATUS_INVINCIBLE 0x0100
#define STATUS_BUFFED    0x0200
```

実装する機能：
1. 複数の状態を同時に設定/解除
2. 特定の状態の組み合わせをチェック
3. 状態の一覧を表示
4. 相反する状態の自動解除（例：凍結と燃焼）

## 演習 12-3: ビットフィールドでメモリ節約
**難易度:** ★★☆

学生の成績データを効率的に格納する構造体を設計してください：

```c
/* 成績データ構造体（ビットフィールド使用） */
struct StudentGrade {
    unsigned int student_id : 20;    /* 学生ID（0-1048575） */
    unsigned int subject_code : 10;  /* 科目コード（0-1023） */
    unsigned int grade : 7;          /* 成績（0-100） */
    unsigned int semester : 2;       /* 学期（1-4） */
    unsigned int year : 7;           /* 年度（0-99, 2000年基準） */
    unsigned int attendance : 1;     /* 出席状況（合格/不合格） */
    unsigned int retake : 1;         /* 再履修フラグ */
};
```

実装する機能：
1. 成績データの入力と表示
2. 通常の構造体とのサイズ比較
3. 成績の統計情報（平均点、最高点、最低点）
4. 条件に合う学生の検索

## 演習 12-4: RGB色操作
**難易度:** ★★☆

RGB565形式（16ビット）の色を操作するプログラムを作成してください：

```c
/* RGB565色構造体 */
typedef struct {
    unsigned int blue  : 5;
    unsigned int green : 6;
    unsigned int red   : 5;
} RGB565;

/* または16ビット整数として扱う */
typedef unsigned short RGB565_int;
```

実装する機能：
1. RGB888（24ビット）⇔ RGB565の相互変換
2. 色の明度調整（明るく/暗く）
3. グレースケール変換
4. 2つの色の混合（アルファブレンド風）

## 演習 12-5: ビットベクタで集合演算
**難易度:** ★★★

ビットベクタを使って集合演算を実装してください：

```c
#define SET_SIZE 256  /* 0-255の整数を扱う */

typedef struct {
    unsigned char bits[SET_SIZE / 8];
} BitSet;
```

実装する機能：
1. 集合の初期化、要素の追加/削除
2. 和集合、積集合、差集合、対称差
3. 部分集合の判定
4. 集合の要素数カウント
5. 集合の内容表示

## 演習 12-6: CRC計算の実装
**難易度:** ★★★

簡単なCRC-8チェックサムを計算する関数を実装してください：

```c
/* CRC-8計算（多項式: x^8 + x^2 + x + 1） */
unsigned char calculate_crc8(const unsigned char *data, int length);
```

実装内容：
1. ビット単位でCRCを計算する基本実装
2. テーブルを使った高速化実装
3. データの破損検出テスト
4. 性能比較

## 演習 12-7: ビットボードでオセロ
**難易度:** ★★★

8×8のオセロ盤面をビットボードで表現してください：

```c
typedef struct {
    unsigned long long black;  /* 黒石の位置 */
    unsigned long long white;  /* 白石の位置 */
} OthelloBoard;
```

実装する機能：
1. 盤面の初期化と表示
2. 石を置ける位置の判定
3. 石を置いた時の反転処理
4. 勝敗判定

## チャレンジ問題

### チャレンジ 12-A: ハフマン符号化
**難易度:** ★★★★

簡単なハフマン符号化を実装してください：

1. 文字の出現頻度をカウント
2. ハフマン木を構築
3. 各文字のビット列を決定
4. テキストをビット列に圧縮
5. ビット列から元のテキストに復元

### チャレンジ 12-B: ブルームフィルタ
**難易度:** ★★★★

確率的データ構造であるブルームフィルタを実装してください：

1. 複数のハッシュ関数の実装
2. 要素の追加
3. 要素の存在確認（偽陽性あり）
4. 偽陽性率の測定

## 演習のヒント

### ビット操作の基本パターン
```c
/* nビット目をセット */
value |= (1 << n);

/* nビット目をクリア */
value &= ~(1 << n);

/* nビット目を反転 */
value ^= (1 << n);

/* nビット目をテスト */
if (value & (1 << n)) { /* ... */ }
```

### ビットマスクの作成
```c
/* 下位nビットのマスク */
mask = (1 << n) - 1;

/* startからcountビット分のマスク */
mask = ((1 << count) - 1) << start;
```

### ビットカウント
```c
/* Brian Kernighanのアルゴリズム */
int count = 0;
while (n) {
    n &= n - 1;
    count++;
}
```

## 提出方法
1. 各演習問題ごとに`ex12_1.c`、`ex12_2.c`...という名前でファイルを作成
2. 動作確認用の`main`関数を含める
3. コメントで実装の工夫や考察を記載

## 評価基準
- **正確性**: 要求された機能が正しく動作するか
- **効率性**: ビット操作の利点を活かした実装か
- **可読性**: コードが理解しやすく整理されているか
- **完成度**: エラー処理やエッジケースへの対応

頑張ってください！

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第13章: 構造体とポインタ - 演習問題


## 基礎問題

### 演習13-1: 学生情報管理

学生の情報（ID、名前、年齢、成績）を格納する構造体を定義し、ポインタを使って情報を表示・更新するプログラムを作成してください。

**要件:**
- 学生情報を表す構造体を定義
- 学生情報を入力する関数を作成
- 学生情報を表示する関数を作成（ポインタ引数）
- 成績を更新する関数を作成（ポインタ引数）

**期待される動作例:**
```
学生情報を入力してください:
ID: 1001
名前: 田中太郎
年齢: 20
成績: 85.5

=== 学生情報 ===
ID: 1001
名前: 田中太郎
年齢: 20歳
成績: 85.5点

新しい成績を入力してください: 90.0
成績を更新しました。

=== 更新後の学生情報 ===
ID: 1001
名前: 田中太郎
年齢: 20歳
成績: 90.0点
```

### 演習13-2: 座標計算

2D座標を表す構造体を定義し、2点間の距離を計算する関数をポインタを使って実装してください。

**要件:**
- 座標を表す構造体（x, y）を定義
- 2点間の距離を計算する関数を作成（ポインタ引数）
- 座標を移動する関数を作成（ポインタで更新）
- math.hのsqrt関数を使用

**期待される動作例:**
```
点1の座標を入力 (x y): 0 0
点2の座標を入力 (x y): 3 4

点1: (0, 0)
点2: (3, 4)
2点間の距離: 5.00

点1を移動します。
移動量を入力 (dx dy): 1 1

移動後の点1: (1, 1)
新しい距離: 3.61
```

### 演習13-3: 商品管理

商品情報（コード、名前、価格、在庫）の構造体を作成し、構造体配列で複数商品を管理するプログラムを作成してください。

**要件:**
- 商品情報を表す構造体を定義
- 最大10個の商品を管理できる配列を用意
- 商品を追加する関数を作成
- 全商品を表示する関数を作成
- 在庫を更新する関数を作成（商品コードで検索）

**期待される動作例:**
```
=== 商品管理システム ===
1. 商品追加
2. 商品一覧表示
3. 在庫更新
0. 終了
選択: 1

商品コード: 101
商品名: ノートPC
価格: 98000
在庫数: 5
商品を追加しました。

選択: 2
=== 商品一覧 ===
コード: 101
商品名: ノートPC
価格: 98000円
在庫: 5個
```

## 応用問題

### 演習11-4: 従業員データベース

従業員情報と部署情報をネストした構造体で管理し、部署別の給与統計を算出するプログラムを作成してください。

**要件:**
- 部署情報を表す構造体（部署名、部署コード）
- 従業員情報を表す構造体（ID、名前、部署情報、給与）
- 部署別の平均給与を計算する関数
- 最高給与の従業員を検索する関数
- 構造体ポインタ配列を使用

### 演習11-5: 図書管理システム

本の情報（タイトル、著者、出版年、貸出状況）を管理し、検索・貸出・返却機能を実装してください。

**要件:**
- 書籍情報を表す構造体を定義
- 貸出状況を管理（貸出中フラグ、借りた人のID）
- タイトルで検索する関数
- 貸出処理を行う関数
- 返却処理を行う関数
- 貸出中の本一覧を表示する関数

### 演習11-6: 成績管理システム

学生と科目の構造体を使って、学生別・科目別の成績統計を管理するプログラムを作成してください。

**要件:**
- 科目情報を表す構造体（科目名、科目コード、単位数）
- 成績情報を表す構造体（学生ID、科目コード、点数、評価）
- 学生別の平均点を計算する関数
- 科目別の平均点を計算する関数
- GPA計算機能（A=4.0, B=3.0, C=2.0, D=1.0, F=0.0）

## 発展問題

### 演習11-7: 動的配列システム

構造体ポインタ配列を動的に拡張できるシステムを実装してください。

**要件:**
- 初期容量を持つ構造体ポインタ配列
- 容量が不足したら自動的に拡張する機能
- メモリ管理を適切に行う
- 要素の追加・削除機能

### 演習11-8: データソート

構造体ポインタ配列を複数の条件（名前、年齢、成績など）でソートできるプログラムを作成してください。

**要件:**
- 複数のソート基準を選択可能
- 昇順・降順の切り替え機能
- ソート用の比較関数を複数実装
- qsort関数を使用

### 演習11-9: 階層データ構造

会社組織（部署→チーム→従業員）のような階層構造を構造体とポインタで表現してください。

**要件:**
- 部署、チーム、従業員の構造体を定義
- 階層関係をポインタで表現
- 組織図を表示する関数
- 特定の部署・チームの人数を集計する関数

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex11_1_student.c`, `ex11_2_coordinate.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex11_1_student.c -o ex11_1_student
./ex11_1_student
```

## ヒント

- 構造体のサイズに注意（パディング）
- ポインタ経由でのメンバーアクセスには->演算子を使用
- 構造体の比較は直接できないため、メンバーごとに比較
- 文字列のコピーにはstrcpy関数を使用
- 構造体を関数に渡す際は、効率のためポインタを使用することを推奨

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第14章: 関数ポインタ - 演習問題


## 演習の目的
- 関数ポインタの基本概念を理解する
- コールバック関数の実装方法を習得する
- 関数ポインタ配列を活用した動的関数選択を学ぶ
- 実行時関数切り替えシステムの設計を理解する

## 演習問題

### 演習14-1: 関数ポインタの基本操作
関数ポインタを使って複数の関数を動的に呼び出すプログラムを作成してください。

**要件:**
- 2つの整数を受け取り、結果を返す関数を複数定義する
- 関数ポインタを使ってこれらの関数を呼び出す
- 関数ポインタ配列を使った実装も含める

**実装すべき関数:**
- `int maximum(int a, int b)` - 大きい方の値を返す
- `int minimum(int a, int b)` - 小さい方の値を返す  
- `int power(int a, int b)` - aのb乗を返す（簡単な実装で可）

**ファイル名:** `ex12_1_basic_function_pointer.c`

### 演習14-2: 関数選択システム
文字に基づいて関数を選択し実行するシステムを実装してください。

**要件:**
- 文字（'+', '-', '*', '/'など）に基づいて関数を選択
- 選択された関数を実行して結果を表示
- 無効な文字が指定された場合のエラーハンドリング
- 構造体を使った関数ポインタ管理

**ファイル名:** `ex12_2_function_selector.c`

### 演習14-3: 配列処理のコールバック
コールバック関数を使って配列の各要素に異なる処理を適用するプログラムを作成してください。

**要件:**
- 整数配列を処理する関数を複数定義
- コールバック関数として配列処理関数に渡す
- 処理前後の配列の状態を表示
- 動的な処理選択機能

**実装すべき処理:**
- 各要素を倍にする
- 各要素から1を引く
- 各要素の符号を反転する

**ファイル名:** `ex12_3_array_callback.c`

### 演習14-4: 関数ポインタ配列を使った計算機
関数ポインタ配列を使用した計算機プログラムを作成してください。

**要件:**
- 関数ポインタの配列を定義
- インデックスを指定して演算を選択
- 複数の演算を連続で実行可能
- 演算履歴を表示する機能
- 統計情報の収集と表示

**実装すべき演算:**
- 加算、減算、乗算、除算
- ゼロ除算のエラーハンドリング

**ファイル名:** `ex12_4_calculator_function_array.c`

## チャレンジ問題

### チャレンジ12-5: ソートアルゴリズム選択システム
異なるソートアルゴリズムを関数ポインタで切り替えるシステムを作成してください。

**要件:**
- バブルソート、選択ソート、挿入ソートを実装
- 比較関数も関数ポインタで指定（昇順/降順）
- ソート前後の配列状態を表示
- アルゴリズムの性能比較機能

**ファイル名:** `ex12_5_sort_algorithms.c`

### チャレンジ12-6: イベント駆動システム
コールバック関数を使ったイベント駆動システムを実装してください。

**要件:**
- 複数種類のイベント（開始、停止、エラー、警告）
- イベントタイプごとに異なるハンドラーを登録
- イベント発生時に適切なハンドラーを呼び出し
- イベントの優先度機能

**ファイル名:** `ex12_6_event_system.c`

## 提出方法

1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex12_1.c`, `ex12_2.c` のような形式で
3. コメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認
5. C99版も作成し、`_c99.c` サフィックスを付ける

## コンパイル例

### C90準拠
```bash
gcc -std=c90 -Wall -Wextra -pedantic ex12_1_basic_function_pointer.c -o ex12_1_basic_function_pointer
```

### C99準拠
```bash
gcc -std=c99 -Wall -Wextra -pedantic ex12_1_basic_function_pointer_c99.c -o ex12_1_basic_function_pointer_c99
```

## 学習のポイント

### 関数ポインタの基本
1. **宣言**: `int (*func_ptr)(int, int);`
2. **初期化**: `func_ptr = function_name;`
3. **呼び出し**: `result = func_ptr(a, b);`
4. **配列**: `int (*operations[])(int, int) = {add, sub, mul};`

### コールバック関数
1. **概念**: 関数を引数として渡す仕組み
2. **活用**: 動的な処理選択、カスタマイズ可能な処理
3. **設計**: 関数ポインタを引数に取る関数の実装

### 実用的なテクニック
1. **関数テーブル**: 構造体による関数ポインタ管理
2. **エラーハンドリング**: 無効な関数ポインタの検出
3. **状態管理**: 関数ポインタによる状態遷移
4. **性能**: 関数ポインタ使用時のオーバーヘッド考慮

## 注意事項

- 関数ポインタは初期化前に使用しない
- 型の一致を厳密に確認する
- NULL ポインタチェックを忘れずに
- デバッグ時は関数名の確認が困難な場合がある

## 実用的な応用

これらの技術は以下のような場面で使用されます。

- **GUI フレームワーク**: イベントハンドラ
- **組み込みシステム**: 割り込みハンドラ
- **ゲーム開発**: 状態管理、AI 行動パターン
- **システムプログラミング**: プラグインシステム

## 次のステップ

この章をマスターしたら、次の章に進みましょう。
- [第13章: 高度なプログラミング技法](../advanced/)
- 関数ポインタを活用したより複雑なシステム設計
- マルチスレッドプログラミングでの関数ポインタ活用

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第15章: 複数ファイル・発展技術 - 演習問題


## 基礎課題

### 演習15-1: プリプロセッサマクロの基本
以下の仕様を満たすプログラムを作成してください。

**仕様：**
- 数学的な定数をマクロで定義する（PI、E、黄金比など）
- 基本的な計算マクロを定義する（面積、体積など）
- 条件付きコンパイルでデバッグ機能を切り替える
- 文字列化マクロと連結マクロを活用する

**実装すべき機能：**
- 円の面積・周長計算
- 球の体積・表面積計算
- デバッグ情報の出力（条件付き）
- マクロによる型安全な最大値・最小値関数

**ファイル名：** `ex13_1_macro_basics.c`

### 演習15-2: 安全なメモリ操作マクロ
メモリ操作の安全性を向上させるマクロ群を作成してください。

**仕様：**
- NULL チェック付きメモリ割り当て
- 配列境界チェック付きアクセス
- 自動的なメモリ解放
- メモリリーク検出機能

**実装すべきマクロ：**
- `SAFE_MALLOC(size)` - NULLチェック付きmalloc
- `SAFE_FREE(ptr)` - NULLクリア付きfree
- `ARRAY_BOUNDS_CHECK(arr, index, size)` - 境界チェック
- `MEMORY_LEAK_TRACKER` - 簡単なリーク検出

**ファイル名：** `ex13_2_safe_memory.c`

### 演習15-3: 基本的なメモリプール
固定サイズオブジェクト用の簡単なメモリプールを実装してください。

**仕様：**
- 事前に確保されたメモリ領域からオブジェクトを割り当て
- フリーリストによる高速な割り当て・解放
- プールの使用状況を表示する機能
- 初期化・終了処理

**実装すべき機能：**
- プールの初期化と終了処理
- オブジェクトの取得と返却
- 使用状況の表示
- エラーハンドリング

**ファイル名：** `ex13_3_memory_pool.c`

## 応用課題

### 演習15-4: 汎用的なプリプロセッサライブラリ
さまざまな用途に使える汎用的なマクロライブラリを作成してください。

**仕様：**
- 型判定マクロ（コンパイル時）
- 汎用的なスワップマクロ
- ループ展開マクロ
- アサーション機能付きマクロ
- ベンチマーク計測マクロ

**実装すべき機能：**
- `TYPE_CHECK(a, b)` - 型の一致確認
- `GENERIC_SWAP(a, b)` - 任意の型のスワップ
- `REPEAT(n, code)` - コードの繰り返し展開
- `BENCHMARK_BLOCK(name)` - ブロックの実行時間測定
- `STATIC_ASSERT(condition, message)` - コンパイル時アサーション

**ファイル名：** `ex13_4_generic_macros.c`

### 演習15-5: 高性能メモリアロケーター
パフォーマンスを重視したカスタムメモリアロケーターを実装してください。

**仕様：**
- サイズ別メモリプール（小・中・大オブジェクト）
- メモリの断片化を最小限に抑える仕組み
- アロケーション統計情報の収集
- スレッドセーフ対応（簡易版）

**実装すべき機能：**
- 複数サイズのメモリプール管理
- First Fit / Best Fit アルゴリズム
- メモリ使用統計とレポート機能
- デバッグモードでの詳細トレース

**ファイル名：** `ex13_5_allocator.c`

### 演習15-6: キャッシュフレンドリーなデータ構造
CPU キャッシュ効率を考慮したデータ構造を実装してください。

**仕様：**
- 配列ベースの動的配列（vector 風）
- キャッシュラインを意識したメモリレイアウト
- プリフェッチを活用した高速アクセス
- メモリプールとの連携

**実装すべき機能：**
- 動的な要素追加・削除
- キャッシュ効率的な反復処理
- バルク操作（一括挿入・削除）
- パフォーマンス測定機能

**ファイル名：** `ex13_6_cache_vector.c`

## 挑戦課題

### 演習13-7: プリプロセッサベースのDSL
プリプロセッサを使ってドメイン固有言語（DSL）を作成してください。

**仕様：**
- 状態機械を記述するDSL
- イベント駆動システムの記述
- 自動的なコード生成
- コンパイル時検証機能

**実装例：**
```c
STATE_MACHINE(TrafficLight)
    STATE(Red)    TIMEOUT() -> Yellow
    STATE(Yellow) TIMEOUT() -> Green  
    STATE(Green)  TIMEOUT() -> Red
END_STATE_MACHINE

EVENT_HANDLER(ButtonPress) 
    // イベント処理コード
END_EVENT_HANDLER
```

**ファイル名：** `ex13_7_dsl.c`

### 演習13-8: 動的メモリ管理フレームワーク
ガベージコレクション機能付きのメモリ管理フレームワークを実装してください。

**仕様：**
- 参照カウント式ガベージコレクション
- 循環参照の検出と解決
- 弱参照（weak reference）のサポート
- メモリプレッシャー対応

**実装すべき機能：**
- オブジェクトの自動管理
- 参照カウントの増減
- 循環参照のマーク&スイープ
- メモリ不足時の自動解放

**ファイル名：** `ex13_8_gc_framework.c`

### 演習13-9: リアルタイムメモリアロケーター
リアルタイムシステム向けの決定的メモリアロケーターを実装してください。

**仕様：**
- O(1) での割り当て・解放保証
- メモリ断片化の完全排除
- 予測可能なメモリ使用量
- 割り込み処理からの安全な使用

**実装すべき機能：**
- 固定時間でのメモリ操作
- 事前確保によるメモリプール
- 優先度別メモリ管理
- リアルタイム統計情報

**ファイル名：** `ex13_9_realtime.c`

## 評価基準

### 基礎課題（各10点）
- 正しく動作する：5点
- コードの可読性：3点
- エラーハンドリング：2点

### 応用課題（各15点）
- 機能の完全性：5点
- パフォーマンス：4点
- 設計の優秀さ：3点
- 拡張性：3点

### 挑戦課題（各20点）
- 実装の完成度：8点
- 創意工夫：5点
- 技術的難易度：4点
- 実用性：3点

## 提出方法

1. 各課題を指定されたファイル名で作成
2. コンパイル用のMakefileを作成
3. 実行例とパフォーマンス結果を含むREADME.mdを作成
4. すべてのファイルを`solutions/`フォルダーに配置

## 学習のポイント

### プリプロセッサの活用
- マクロの安全な使用方法
- 条件付きコンパイルの効果的な活用
- コード生成の自動化
- デバッグ支援機能

### メモリ管理の最適化
- メモリプールの設計と実装
- キャッシュ効率を考慮したデータ構造
- パフォーマンス測定と改善
- メモリリークの検出と防止

### 高度なC言語技法
- 型安全なプログラミング
- コンパイル時計算の活用
- ハードウェア特性を考慮した実装
- システムプログラミング技法

## 参考資料

### プリプロセッサ高度技法
```c
// X-マクロパターン
#define COLORS \
    X(RED, "赤") \
    X(GREEN, "緑") \
    X(BLUE, "青")

typedef enum {
#define X(name, desc) COLOR_##name,
    COLORS
#undef X
    COLOR_COUNT
} Color;

const char* color_names[] = {
#define X(name, desc) desc,
    COLORS
#undef X
};
```

### メモリアライメント最適化
```c
// キャッシュライン境界でのアライメント
#define CACHE_LINE_SIZE 64
#define CACHE_ALIGNED __attribute__((aligned(CACHE_LINE_SIZE)))

typedef struct CACHE_ALIGNED {
    int frequently_accessed_data;
    char padding[CACHE_LINE_SIZE - sizeof(int)];
} CacheOptimizedStruct;
```

### 高性能メモリ操作
```c
// SIMD命令を使った高速メモリコピー
#include <immintrin.h>

void fast_memcpy(void* dst, const void* src, size_t size) {
    // AVXを使った実装例
    if (size >= 32 && ((intptr_t)dst & 31) == 0 && ((intptr_t)src & 31) == 0) {
        // 32バイト境界でアラインされている場合の最適化
    }
}
```

## よくある間違いとその対策

### 1. マクロの副作用
**間違い：**
```c
#define SQUARE(x) x * x
int a = 5;
int result = SQUARE(++a);  // a が2回インクリメントされる
```

**正解：**
```c
#define SQUARE(x) ({ \
    typeof(x) _temp = (x); \
    _temp * _temp; \
})
```

### 2. メモリアライメントの無視
**間違い：**
```c
char buffer[100];
int* ptr = (int*)&buffer[1];  // 不正なアライメント
```

**正解：**
```c
#include <stdalign.h>
alignas(int) char buffer[100];
int* ptr = (int*)buffer;
```

### 3. キャッシュ効率の無視
**間違い：**
```c
// 列優先アクセス（キャッシュミスが多発）
for (int j = 0; j < cols; j++) {
    for (int i = 0; i < rows; i++) {
        matrix[i][j] = value;
    }
}
```

**正解：**
```c
// 行優先アクセス（キャッシュフレンドリー）
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = value;
    }
}
```

これらの課題を通じて、C言語の高度な機能を習得し、パフォーマンスを意識したプログラミングスキルを身につけてください。

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第16章: C23の新機能 - 演習問題


C23の新機能を活用した演習問題です。

## 演習16-1: bool型の活用

bool型を使用して、簡単な状態管理システムを作成してください。

### 要件。
- システムの各種状態をbool型で管理
- 状態の組み合わせによる判定ロジック
- 状態表示関数の実装

### ヒント。
```c
typedef struct {
    bool is_connected;
    bool is_authenticated;
    bool has_permission;
    bool is_busy;
} SystemStatus;
```

---

## 演習16-2: ビット操作と2進数リテラル

2進数リテラルを使用して、8ビットのフラグ管理システムを作成してください。

### 要件。
- 各ビットが異なる機能のON/OFFを表す
- ビットの設定、クリア、トグル、チェック関数
- 現在の状態を2進数で表示

### 例。
```c
#define FLAG_READ    0b00000001
#define FLAG_WRITE   0b00000010
#define FLAG_EXECUTE 0b00000100
// ... 続く
```

---

## 演習16-3: typeof演算子の応用

typeof演算子を使用して、汎用的なデータ構造操作マクロを作成してください。

### 要件。
- 配列の最大値・最小値を求めるマクロ
- 2つの変数を安全に交換するマクロ
- 配列要素の合計を計算するマクロ

### 例。
```c
#define ARRAY_MAX(arr, size) ({ \
    typeof(arr[0]) max = arr[0]; \
    /* 実装を完成させる */ \
    max; \
})
```

---

## 演習16-4: nullptr安全プログラミング

nullptrを活用して、安全なリンクリスト操作関数を作成してください。

### 要件。
- ノードの追加、削除、検索
- すべてのポインタ操作でnullptrチェック
- エラーハンドリングの実装

---

## 演習14-5: C23総合演習

C23の複数の新機能を組み合わせた小規模なプログラムを作成してください。

### テーマ例。
1. **設定管理システム**
   - bool型で各種設定のON/OFF
   - 2進数リテラルでフラグ管理
   - nullptrで安全なポインタ操作

2. **簡易デバッガ**
   - typeof演算子で変数情報取得
   - 2進数表示機能
   - メモリダンプ機能

3. **ビット演算計算機**
   - 2進数リテラルで入力
   - ビット演算の結果表示
   - 教育的な説明付き

---

## 提出方法

1. 各演習の解答を`solutions/`ディレクトリに作成
2. ファイル名: `ex14_1_status_system.c`のような形式
3. 十分なコメントを含めること

## 評価基準

- C23機能の適切な使用
- コードの可読性
- エラーハンドリング
- 実行時の安定性

# 上級編を修了して

## 習得したスキル

上級編の演習問題を通じて、以下の高度なスキルを習得しました：

### システムレベルプログラミング
- [ ] ビット操作による効率的なデータ処理
- [ ] メモリレイアウトの理解と最適化
- [ ] ハードウェア制御の基礎

### 高度なデータ構造
- [ ] 構造体を使った複雑なデータモデリング
- [ ] リンクリストやツリー構造の実装
- [ ] メモリ効率を考慮した設計

### 関数型プログラミング要素
- [ ] 関数ポインタによる高階関数
- [ ] コールバックパターンの実装
- [ ] 汎用的なアルゴリズムの設計

### プロジェクト構成
- [ ] 複数ファイルによるモジュール設計
- [ ] ヘッダファイルの適切な管理
- [ ] 再利用可能なライブラリの作成

## 実務への応用

これらのスキルは、以下のような分野で活用できます：

1. **組み込みシステム開発**
   - マイコンプログラミング
   - リアルタイムシステム

2. **システムプログラミング**
   - OS開発
   - デバイスドライバ

3. **高性能コンピューティング**
   - 数値計算
   - ゲームエンジン

## 継続的な学習

プログラミングスキルを維持・向上させるために：

1. **コードリーディング**
   - オープンソースプロジェクトのソースコードを読む
   - 優れたC言語プロジェクトから学ぶ

2. **プロジェクト実践**
   - 自分でツールやライブラリを作成
   - 既存プロジェクトへの貢献

3. **新技術の探求**
   - C標準の最新動向をフォロー
   - 関連技術（Rust、Zig等）の学習

## 最後に

C言語は、コンピュータサイエンスの基礎を学ぶ上で最適な言語です。本教材で学んだ知識は、他のプログラミング言語を学ぶ際にも必ず役立ちます。

これからも挑戦を続け、素晴らしいソフトウェアを作り出してください！

