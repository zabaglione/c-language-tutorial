---
title: "C言語プログラミング教材 - 演習問題集（応用編）"
subtitle: "第7章〜第11章の演習問題"
author: "C言語学習教材プロジェクト"
date: "2024年"
documentclass: report
lang: ja
fontsize: 12pt
geometry: margin=1in
toc: true
toc-depth: 2
numbersections: true
---

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```

# はじめに

本書は、C言語プログラミング教材応用編の演習問題集です。配列、ポインタ、文字列、関数など、C言語の中核となる概念を実践的に習得するための問題を収録しています。

## 前提知識

応用編の演習問題に取り組む前に、基礎編の内容を十分に理解していることが必要です：

- 基本的な文法とデータ型
- 演算子の使い方
- 条件分岐とループ

## 演習問題の難易度

応用編では、より実践的な問題を扱います：

- **基礎問題**: 新しい概念の基本的な使い方
- **応用問題**: 実務で遭遇する典型的な課題
- **発展問題**: アルゴリズムとデータ構造の応用

## ポインタ学習の重要性

特に第8章〜第9章のポインタ関連の演習は、C言語習得の要となります。じっくりと時間をかけて取り組んでください。

---


```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第7章: 配列（基本編） - 演習問題


## 演習の目的
- 1次元配列と多次元配列の理解を深める
- 配列を使った実践的な問題解決能力を養う
- 基本的な配列操作をマスターする

## 演習問題

### 演習7-1: 配列の基本操作 
整数配列に対する各種操作を実行するプログラムを作成してください。

**要件:**
- 5個の整数を入力して配列に格納
- 以下の操作を実装:
  - 配列の全要素を表示
  - 最大値と最小値を見つける
  - 平均値を計算
  - 配列を逆順に並べ替える
  - 指定した値が配列内に存在するか検索

**実装のヒント:**
- 配列のサイズは#defineで定義
- 逆順は別の配列にコピーまたはその場で交換

### 演習7-2: 成績管理システム 
複数の学生の複数科目の成績を管理するプログラムを作成してください。

**要件:**
- 5人の学生、4科目（国語、数学、英語、理科）の成績を2次元配列で管理
- 各学生の合計点と平均点を計算
- 各科目の平均点を計算
- 最高得点の学生と科目を表示
- 成績表を見やすく表示

**実装のヒント:**
- 2次元配列 grades[][] を使用
- 行が学生、列が科目

### 演習7-3: 配列の要素シフト 
配列の要素を左右にシフトするプログラムを作成してください。

**要件:**
- 10個の整数を配列に格納
- 以下の操作を実装:
  - 全要素を右に1つシフト（最後の要素は先頭へ）
  - 全要素を左に1つシフト（最初の要素は最後へ）
  - 指定した数だけシフト
  - シフト前後の配列を表示

**実装のヒント:**
- 一時変数を使って端の要素を保存
- ループの方向に注意

### 演習7-4: 行列演算
2次元配列を使って行列演算を実行するプログラムを作成してください。

**要件:**
- 3x3の行列を2つ入力
- 以下の演算を実装:
  - 行列の加算
  - 行列の減算
  - 行列の乗算
  - 転置行列の計算

**実装のヒント:**
- 行列の乗算: result[i][j] = Σ(a[i][k] * b[k][j])
- 各演算結果を見やすく表示

### 演習7-5: 配列の統計処理 
整数配列に対する各種統計処理を行うプログラムを作成してください。

**要件:**
- 20個の整数データを配列に格納
- 以下の統計値を計算:
  - 合計値と平均値
  - 最大値と最小値およびその位置
  - 中央値（配列をソートして求める）
  - 最頻値（最も多く出現する値）

**実装のヒント:**
- ソートには簡単なバブルソートを使用
- 最頻値は別の配列で出現回数をカウント

## チャレンジ問題

### チャレンジ7-1: ソートアルゴリズムの実装
配列のソートアルゴリズムを複数実装して比較してください。

**要件:**
- 以下のソートアルゴリズムを実装:
  - バブルソート
  - 選択ソート
  - 挿入ソート
- 各アルゴリズムの実行時間を測定
- ランダムな配列、ソート済み配列、逆順配列で性能比較

**追加要件:**
- 比較回数と交換回数をカウント
- 結果をグラフィカルに表示（*を使った簡易グラフ）

### チャレンジ7-2: ライフゲーム（Conway's Game of Life）
セル・オートマトンの一種であるライフゲームを実装してください。

**要件:**
- 20x20のグリッドで実装
- 初期パターンを設定可能
- 以下のルールを実装:
  - 生きているセルの周囲に2-3個の生きたセルがあれば生存
  - 死んでいるセルの周囲にちょうど3個の生きたセルがあれば誕生
  - それ以外は死亡
- 世代を進めるごとに画面をクリアして表示

**実装のヒント:**
- 2つの2次元配列を使用（現在と次世代）
- 境界条件の処理に注意

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex7_1.c`, `ex7_2.c` のような形式で
3. 配列のサイズや境界チェックに特に注意
4. メモリアクセスエラーが起きないよう十分にテスト

## 期限
配列は多くのプログラムの基礎となるデータ構造です。
しっかりと理解してから次の章へ進みましょう。

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第8章: ポインタ基礎 - 演習問題


## 基礎問題

### 演習10-1: ポインタの基本操作

2つの整数変数の値をポインタを使って交換するプログラムを作成してください。

**要件:**
- 2つの整数変数を宣言・初期化
- ポインタを使った値の交換関数を実装
- 交換前後の値とアドレスを表示
- 直接的な値の交換とポインタ経由の交換を比較

**期待される出力例:**
```
交換前: a =  (アドレス: xffffbffac), b =  (アドレス: xffffbffa)
ポインタを使った交換実行...
交換後: a =  (アドレス: xffffbffac), b =  (アドレス: xffffbffa)
```

### 演習10-2: 配列とポインタ

ポインタ演算を使って配列の要素を逆順に表示するプログラムを作成してください。

**要件:**
- 整数配列を宣言・初期化
- ポインタ演算で配列の最後から最初に向かってアクセス
- インデックス記法とポインタ記法の両方で表示
- 配列のサイズを動的に計算

### 演習10-3: 文字列操作

ポインタを使って文字列の長さを計算し、文字列を逆順にするプログラムを作成してください。

**要件:**
- 文字列の長さ計算関数（strlen相当）をポインタで実装
- 文字列を逆順にする関数をポインタで実装
- 元の文字列と逆順文字列を表示
- 文字列リテラルと文字配列の違いを考慮

## 応用問題

### 演習10-4: 配列操作関数

ポインタを使って配列の最大値、最小値、平均値を計算する関数群を作成してください。

**要件:**
- 最大値を見つけてそのポインタを返す関数
- 最小値を見つけてそのポインタを返す関数
- 平均値を計算する関数（戻り値はdouble）
- 各関数の結果を使ってレポートを作成

**実装する関数:**
```c
int* find_max(int *arr, int size);
int* find_min(int *arr, int size);
double calculate_average(int *arr, int size);
void print_statistics(int *arr, int size);
```

### 演習10-5: 文字列処理

ポインタを使って文字列の検索、置換、分割を実行する関数群を作成してください。

**要件:**
- 文字列内で特定の文字を検索する関数
- 文字列内の文字を置換する関数
- 文字列を特定の文字で分割する関数
- 大文字・小文字を無視した比較機能

### 演習10-6: データ変換

ポインタを使って配列のデータ型変換を実行するプログラムを作成してください。

**要件:**
- int配列をfloat配列に変換
- 文字列を数値配列に変換
- バイト配列を整数として解釈
- エラーハンドリングの実装

## 発展問題

### 演習10-7: メモリ操作

ポインタを使って任意のデータ型の配列をコピーする汎用関数を作成してください。

**要件:**
- void*ポインタを使った汎用コピー関数
- バイト単位でのメモリコピー
- 型安全性の考慮
- コピー対象の境界チェック

**関数プロトタイプ:**
```c
void* generic_copy(void *dest, const void *src, size_t size);
int compare_memory(const void *ptr, const void *ptr, size_t size);
```

### 演習10-8: アルゴリズム実装

ポインタを使って各種ソートアルゴリズムを実装してください。

**要件:**
- バブルソート（ポインタ版）
- 選択ソート（ポインタ版）
- 挿入ソート（ポインタ版）
- 汎用的な比較関数の使用

### 演習10-9: データ構造

ポインタを使って簡単なリンクリスト構造を実装してください。

**要件:**
- ノード構造体の定義
- リストへの要素追加・削除
- リストの走査・検索
- メモリリークの防止

**構造体例:**
```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;
```

## チャレンジ問題

### 演習10-10: 動的配列シミュレータ

malloc/freeを使わずに、静的配列とポインタを使って動的配列のような動作を実現してください。

**要件:**
- 固定サイズの大きな配列をメモリプールとして使用
- 要素の追加・削除・挿入機能
- メモリの断片化管理
- ガベージコレクション機能

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex_pointer_swap.c`, `ex_array_reverse.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex_pointer_swap.c -o ex_pointer_swap
./ex_pointer_swap
```

## ヒント

### ポインタの基本
- 宣言: `int *ptr;`
- アドレス取得: `ptr = &variable;`
- 値の取得: `value = *ptr;`
- 演算: `ptr + 1` は次の要素を指す

### 安全なプログラミング
- NULLポインタのチェック: `if (ptr != NULL)`
- 配列の境界チェック
- 初期化されていないポインタの使用を避ける

### デバッグのコツ
- アドレスと値を分けて表示
- ポインタ演算の結果を段階的に確認
- コンパイラの警告に注意を払う

### よくある間違い
- `*ptr++` と `(*ptr)++` の違い
- ローカル変数のアドレスを返すこと
- 配列の範囲外アクセス
- NULLポインタの参照

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第9章: 配列とポインタ - 演習問題


## 演習の目的
- 配列とポインタの関係を深く理解する
- ポインタ演算を使った配列操作をマスターする
- 関数への配列の渡し方を習得する
- より効率的な配列処理技術を身につける

## 演習問題

### 演習9-1: ポインタによる配列走査 
ポインタを使って配列を操作するプログラムを作成してください。

**要件:**
- 10個の整数を配列に格納
- 以下の操作をポインタを使って実装:
  - 配列の全要素を表示（配列記法を使わない）
  - 最大値と最小値を見つける（ポインタ演算使用）
  - 配列を逆順に並べ替える（ポインタで実装）
  - 特定の値を検索し、そのアドレスを返す

**実装のヒント:**
- arr[i] の代わりに *(arr + i) を使用
- ポインタのインクリメント/デクリメントを活用

### 演習9-2: 関数への配列渡し 
配列を関数に渡して操作するプログラムを作成してください。

**要件:**
- 配列操作を行う以下の関数を実装:
  - 配列の要素をすべてn倍する関数
  - 2つの配列を要素ごとに加算する関数
  - 配列内の最大値へのポインタを返す関数
  - 配列を指定位置で分割する関数

**実装のヒント:**
- 関数の引数は int *arr または int arr[]
- サイズ情報は別引数で渡す

### 演習9-3: 文字列のポインタ操作 
文字列をポインタで操作するプログラムを作成してください。

**要件:**
- ポインタを使った以下の文字列関数を実装:
  - 文字列の長さを計算（strlen相当）
  - 文字列をコピー（strcpy相当）
  - 文字列を連結（strcat相当）
  - 文字列を反転

**実装のヒント:**
- char *を使った操作
- null終端文字の処理に注意

### 演習9-4: 多次元配列とポインタ
2次元配列をポインタで操作するプログラムを作成してください。

**要件:**
- 3×3の行列に対する以下の操作:
  - ポインタを使った要素アクセス
  - 行列の転置（ポインタ使用）
  - 対角要素の合計
  - 行ごと、列ごとの合計

**実装のヒント:**
- *(*(arr + i) + j) でアクセス
- int (*ptr)[3] の使い方を理解

### 演習9-5: 動的配列の模擬 
ポインタを使った配列の動的な操作を行うプログラムを作成してください。

**要件:**
- 固定サイズ配列を使いながら動的配列のような操作:
  - 使用中の要素数を管理
  - 要素の追加（容量チェック付き）
  - 要素の削除（詰める処理）
  - 配列の拡張（別の大きな配列へコピー）

**実装のヒント:**
- 実際の要素数と配列容量を別管理
- ポインタを使った効率的なコピー

## チャレンジ問題

### チャレンジ9-1: 高速文字列検索
ポインタを使った効率的な文字列検索アルゴリズムを実装してください。

**要件:**
- Boyer-Moore法の簡易版を実装:
  - 文字列内から部分文字列を検索
  - 見つかった位置のポインタを返す
  - 複数箇所で見つかる場合は全て表示

**追加要件:**
- 検索回数をカウントして効率性を評価
- 通常の逐次検索と比較

### チャレンジ9-2: メモリプールの実装
大きな配列を使ったメモリプールを実装してください。

**要件:**
- 大きな char配列をメモリプールとして使用
- 以下の機能を実装:
  - 指定サイズのメモリ割り当て
  - メモリの解放
  - 使用状況の表示
  - フラグメンテーションの管理

**実装のヒント:**
- ポインタ演算でメモリブロックを管理
- 各ブロックの使用状況をヘッダで管理

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex9_1.c`, `ex9_2.c` のような形式で
3. ポインタの使用を明確にコメントで説明
4. 境界チェックを忘れずに実装

## 学習のポイント
- 配列記法とポインタ記法の変換を意識
- ポインタ演算の正確な理解
- 関数への配列渡しの仕組みを完全に理解
- メモリレイアウトを常に意識して実装

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第10章: 文字列処理 - 演習問題


この章では、C言語における文字列操作の基本から応用まで、段階的に学習できる演習問題を提供しています。

## 演習の概要

文字列処理は、プログラミングにおいて最も基本的かつ重要な技術の一つです。この演習では、以下の3つの段階で文字列操作を習得します。

### 学習目標

1. **基本的な文字列操作の理解**
   - null終端文字列の概念
   - ポインタと配列の関係
   - メモリ安全な文字列操作

2. **文字列配列の管理**
   - 二次元配列の操作
   - 動的な要素の追加・削除
   - ソートと検索アルゴリズム

3. **高度な文字列処理**
   - パターンマッチング
   - アルゴリズムの最適化
   - 実用的な応用例

## 演習問題一覧

### 演習8-1: 基本的な文字列操作

**難易度**: 初級  
**所要時間**: 2-3時間

標準ライブラリの関数を使わずに、基本的な文字列操作関数を実装します。

**実装する関数**:
1. `my_strlen()` - 文字列の長さを計算
2. `my_strcpy()` - 文字列をコピー
3. `my_strcmp()` - 文字列を比較
4. `my_strcat()` - 文字列を連結
5. `my_strchr()` - 文字を検索
6. `my_strrchr()` - 文字を後方検索
7. `count_char()` - 特定文字をカウント

**学習ポイント**:
- null終端文字列の仕組み
- ポインタ演算の基礎
- バッファオーバーフロー対策
- エラーハンドリング

### 演習8-2: 文字列配列の管理

**難易度**: 中級  
**所要時間**: 3-4時間

学生名を格納する文字列配列の管理システムを実装します。

**実装する機能**:
1. **配列管理機能**
   - 学生名の追加・削除
   - 重複チェック
   - 配列の動的管理

2. **検索とソート機能**
   - 名前による検索
   - アルファベット順ソート
   - 一覧表示機能

**学習ポイント**:
- 二次元配列の操作
- 配列要素の挿入・削除
- バブルソートアルゴリズム
- 線形検索の実装

### 演習8-3: 高度な文字列検索

**難易度**: 上級  
**所要時間**: 4-6時間

標準ライブラリを使わずに、高度な文字列検索機能を実装します。

**実装する機能**:
1. **検索機能**
   - 大小文字を区別しない検索
   - 単語境界での検索
   - 部分文字列検索

2. **パターンマッチング**
   - ワイルドカード検索（*、?）
   - 複数パターンの同時検索
   - 検索結果の詳細情報

**学習ポイント**:
- 高度な文字列マッチングアルゴリズム
- メモリ効率的な実装
- 動的プログラミング
- パフォーマンス最適化

## 提出要件

各演習について、以下の要件を満たしてください。

### 必須要件

1. **ソースコード**
   - 適切なコメント（日本語）
   - 関数の詳細な説明
   - エラーハンドリング

2. **テストプログラム**
   - 各関数の動作確認
   - 境界値テスト
   - エラーケースのテスト

3. **実行例**
   - 正常ケースの実行結果
   - エラーケースの実行結果

### 推奨要件

1. **コーディングスタイル**
   - 一貫したインデント
   - 意味のある変数名
   - 適切な関数分割

2. **安全性**
   - バッファオーバーフロー対策
   - NULLポインタチェック
   - メモリリークの防止

## 評価基準

### 正確性 (40%)
- 仕様通りに動作するか
- エラーケースが適切に処理されるか
- テストケースが網羅的か

### 安全性 (30%)
- バッファオーバーフローがないか
- メモリ管理が適切か
- 入力検証が十分か

### 効率性 (20%)
- アルゴリズムの計算量が適切か
- 不要な処理がないか
- メモリ使用量が最適か

### 可読性 (10%)
- コードが理解しやすいか
- コメントが適切か
- 命名規則が一貫しているか

## 学習の進め方

### 推奨手順

1. **基礎の理解**
   - 文字列の基本概念を復習
   - ポインタと配列の関係を確認
   - null終端文字列の仕組みを理解

2. **段階的実装**
   - 演習1から順番に取り組む
   - 小さな関数から実装開始
   - テストケースを先に作成

3. **デバッグとテスト**
   - コンパイル時の警告を確認
   - 実行時エラーをチェック
   - メモリ使用状況を監視

4. **最適化と改善**
   - パフォーマンスを測定
   - コードの可読性を向上
   - エラーハンドリングを強化

### 学習のヒント

1. **安全第一**
   - 配列の境界を常に確認
   - NULLポインタをチェック
   - バッファサイズを適切に管理

2. **テスト駆動**
   - 関数作成前にテストケースを考える
   - エッジケースを忘れずに
   - 段階的に機能を拡張

3. **効率性の考慮**
   - 不要な文字列コピーを避ける
   - ポインタ操作を活用
   - メモリ使用量を最適化

## トラブルシューティング

### よくある問題

1. **セグメンテーション違反**
   - 配列の境界越え
   - null終端の忘れ
   - 未初期化ポインタ

2. **予期しない出力**
   - null終端文字の扱い
   - 文字コードの問題
   - バッファの不足

3. **メモリリーク**
   - 動的メモリの解放忘れ
   - 重複した確保
   - 例外時の処理不備

### デバッグ方法

1. **printfデバッグ**
   - 変数の値を確認
   - 関数の呼び出し順序を追跡
   - 配列の内容を表示

2. **gdbの使用**
   - ブレークポイントの設定
   - ステップ実行
   - 変数の監視

3. **静的解析ツール**
   - コンパイラの警告
   - lintツールの使用
   - メモリチェッカー

## 参考資料

### 必読資料
- [文字列操作の基礎](../README.md)
- [実装例とサンプルコード](../examples/)
- [解答例](../solutions/)

### 推奨図書
- 『プログラミング言語C 第2版』（K&R）
- 『Cプログラミング専門課程』
- 『セキュアプログラミング講座』

### オンラインリソース
- C言語標準ライブラリリファレンス
- 文字列処理アルゴリズム
- セキュアコーディング標準

---

これらの演習を通じて、C言語における文字列操作の基礎から応用まで、体系的に学習することができます。各演習に丁寧に取り組み、安全で効率的なコードの作成技術を身につけてください。

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# 第11章: 関数 - 演習問題


## 基本課題

### 課題9-1: 基本的な関数作成
以下の関数を作成してください。

1. **数学関数**
   - 2つの整数の最大値を返す関数 `int max(int a, int b)`
   - 3つの整数の最小値を返す関数 `int min(int a, int b, int c)`
   - 数値が偶数かどうかを判定する関数 `int is_even(int n)`
   - 数値が素数かどうかを判定する関数 `int is_prime(int n)`

2. **文字・文字列関数**
   - 文字が英字かどうかを判定する関数 `int is_letter(char c)`
   - 文字列の長さを計算する関数 `int my_strlen(const char str[])`
   - 文字列内の特定文字を数える関数 `int count_char(const char str[], char ch)`

3. **表示関数**
   - 指定した長さの線を描く関数 `void draw_line(int length, char ch)`
   - 数値を指定した桁数で表示する関数 `void print_number_padded(int num, int width)`

### 課題9-2: 配列操作関数
以下の配列操作関数を作成してください。

1. **基本操作**
   - 配列の要素の合計を計算する関数 `int array_sum(int arr[], int size)`
   - 配列の平均値を計算する関数 `double array_average(int arr[], int size)`
   - 配列内の最大値のインデックスを返す関数 `int find_max_index(int arr[], int size)`

2. **検索・ソート**
   - 線形検索関数 `int linear_search(int arr[], int size, int target)`
   - 配列を昇順にソートする関数 `void sort_array(int arr[], int size)`
   - 配列の要素を逆順にする関数 `void reverse_array(int arr[], int size)`

3. **配列統計**
   - 配列の最大値と最小値を同時に求める関数 `void find_min_max(int arr[], int size, int *min, int *max)`
   - 配列内の重複する要素の数を数える関数 `int count_duplicates(int arr[], int size)`

### 課題9-3: 文字列処理関数
以下の文字列処理関数を作成してください。

1. **基本処理**
   - 文字列をコピーする関数 `void my_strcpy(char dest[], const char src[])`
   - 文字列を連結する関数 `void my_strcat(char dest[], const char src[])`
   - 文字列を比較する関数 `int my_strcmp(const char str1[], const char str2[])`

2. **変換処理**
   - 文字列を大文字に変換する関数 `void to_uppercase(char str[])`
   - 文字列を小文字に変換する関数 `void to_lowercase(char str[])`
   - 文字列を逆順にする関数 `void reverse_string(char str[])`

3. **解析処理**
   - 文字列内の単語数を数える関数 `int count_words(const char str[])`
   - 文字列が回文かどうかを判定する関数 `int is_palindrome(const char str[])`
   - 文字列内の母音の数を数える関数 `int count_vowels(const char str[])`

## 中級課題

### 課題9-4: 複数戻り値を持つ関数
以下の関数を作成してください。

1. **時間計算**
   - 秒数を時分秒に変換する関数 `void seconds_to_hms(int total_seconds, int *hours, int *minutes, int *seconds)`
   - 日数から年月日に変換する関数（365日/年として） `void days_to_ymd(int total_days, int *years, int *months, int *days)`

2. **座標計算**
   - 2点間の距離と中点を計算する関数 `void calculate_line_info(double x1, double y1, double x2, double y2, double *distance, double *mid_x, double *mid_y)`
   - 円の面積と周囲の長さを計算する関数 `void calculate_circle_info(double radius, double *area, double *circumference)`

3. **統計計算**
   - 配列の統計情報を計算する関数 `void calculate_statistics(int arr[], int size, int *min, int *max, double *mean, double *median)`
   - 成績から評価を計算する関数 `void calculate_grade_info(int scores[], int count, double *average, char *grade, int *pass_count)`

### 課題9-5: エラーハンドリング付き関数
安全性を考慮した以下の関数を作成してください。

1. **安全な基本操作**
   - 安全な除算関数 `int safe_divide(double a, double b, double *result)`
   - 安全な配列アクセス関数 `int safe_array_get(int arr[], int size, int index, int *value)`
   - 安全な文字列コピー関数 `int safe_strcpy(char dest[], int dest_size, const char src[])`

2. **範囲チェック付き関数**
   - 範囲指定付きランダム数生成関数 `int random_range(int min, int max, int *result)`
   - 配列の範囲チェック付き設定関数 `int safe_array_set(int arr[], int size, int index, int value)`

3. **バリデーション関数**
   - 文字列が数値として有効かチェックする関数 `int is_valid_number(const char str[])`
   - メールアドレスの基本形式をチェックする関数 `int is_valid_email(const char email[])`

### 課題9-6: 構造体を使った関数
以下の構造体を使った関数を作成してください。

```c
typedef struct {
    double x;
    double y;
} Point;

typedef struct {
    int id;
    char name[50];
    int age;
    double score;
} Student;

typedef struct {
    int year;
    int month;
    int day;
} Date;
```

1. **座標操作**
   - 2点間の距離を計算する関数 `double point_distance(Point p1, Point p2)`
   - 点を移動する関数 `Point move_point(Point p, double dx, double dy)`
   - 複数の点の重心を計算する関数 `Point calculate_centroid(Point points[], int count)`

2. **学生情報処理**
   - 学生情報を表示する関数 `void print_student(Student s)`
   - 学生の成績を更新する関数 `void update_score(Student *s, double new_score)`
   - 学生配列から最高得点者を見つける関数 `Student find_best_student(Student students[], int count)`

3. **日付操作**
   - 日付を表示する関数 `void print_date(Date d)`
   - 日付の妥当性をチェックする関数 `int is_valid_date(Date d)`
   - 2つの日付の差を計算する関数 `int date_difference(Date d1, Date d2)`

## 上級課題

### 課題9-7: 再帰関数
以下の再帰関数を作成してください。

1. **数学的再帰**
   - 階乗を計算する再帰関数 `long factorial_recursive(int n)`
   - フィボナッチ数列を計算する再帰関数 `int fibonacci_recursive(int n)`
   - ユークリッドの互除法による最大公約数を求める再帰関数 `int gcd_recursive(int a, int b)`

2. **文字列再帰**
   - 文字列が回文かどうか再帰的に判定する関数 `int is_palindrome_recursive(const char str[], int start, int end)`
   - 文字列を再帰的に逆順にする関数 `void reverse_string_recursive(char str[], int start, int end)`

3. **配列再帰**
   - 配列の合計を再帰的に計算する関数 `int array_sum_recursive(int arr[], int size)`
   - 配列の最大値を再帰的に見つける関数 `int find_max_recursive(int arr[], int size)`

### 課題9-8: 高度な文字列処理
以下の高度な文字列処理関数を作成してください。

1. **文字列解析**
   - 文字列をトークンに分割する関数 `int tokenize(char str[], char tokens[][50], char delimiter)`
   - 文字列内の括弧の対応をチェックする関数 `int check_brackets(const char str[])`
   - 文字列から数値を抽出する関数 `int extract_numbers(const char str[], int numbers[], int max_count)`

2. **パターンマッチング**
   - 簡単なワイルドカード（*、?）パターンマッチング関数 `int wildcard_match(const char str[], const char pattern[])`
   - 文字列の置換関数 `int string_replace(char str[], const char old_substr[], const char new_substr[])`

3. **文字列フォーマット**
   - 文字列を指定幅で中央揃えする関数 `void center_string(char result[], const char str[], int width)`
   - CSV形式の文字列を解析する関数 `int parse_csv_line(const char line[], char fields[][100], int max_fields)`

### 課題9-9: ソートアルゴリズム関数
以下のソートアルゴリズムを関数として実装してください。

1. **基本ソート**
   - バブルソート `void bubble_sort(int arr[], int size)`
   - 選択ソート `void selection_sort(int arr[], int size)`
   - 挿入ソート `void insertion_sort(int arr[], int size)`

2. **高速ソート**
   - マージソート `void merge_sort(int arr[], int left, int right)`
   - クイックソート `void quick_sort(int arr[], int left, int right)`

3. **特殊ソート**
   - 文字列配列のソート `void sort_strings(char strings[][100], int count)`
   - 構造体配列のソート（複数キー対応）`void sort_students(Student students[], int count, int sort_by)`

## 挑戦課題

### 課題9-10: 関数ポインター
以下の関数ポインターを使った課題に取り組んでください。

1. **計算機関数**
   - 四則演算を関数ポインターで切り替える計算機 `double calculator(double a, double b, double (*operation)(double, double))`
   - 配列に対する処理を関数ポインターで指定する関数 `void process_array(int arr[], int size, void (*processor)(int*))`

2. **ソート関数の汎用化**
   - 比較関数を引数に取る汎用ソート関数 `void generic_sort(void *arr, int size, int elem_size, int (*compare)(const void*, const void*))`

3. **コールバック関数**
   - イベント処理システム `void register_callback(int event_type, void (*callback)(int))`

### 課題9-11: メモリ効率を考慮した関数
メモリ使用量を最適化した関数を作成してください。

1. **動的メモリ管理**
   - 動的配列を管理する関数群
   - 文字列プールを管理する関数群
   - メモリリークを検出する関数

2. **効率的なアルゴリズム**
   - インプレース（元の配列内で処理）ソート関数
   - メモリ使用量を抑えた文字列処理関数
   - キャッシュ効率を考慮した配列処理関数

### 課題9-12: 総合プロジェクト
複数の関数を組み合わせた総合的なプロジェクトを作成してください。

1. **学生管理システム**
   - 学生情報の登録、検索、更新、削除機能
   - 成績統計の計算機能
   - データのファイル保存・読み込み機能

2. **テキスト解析ツール**
   - ファイルの読み込みと解析
   - 単語頻度の統計
   - 文字列パターンの検索

3. **数値計算ライブラリ**
   - 行列演算機能
   - 統計計算機能
   - 数値積分・微分機能

## 提出要件

各課題について、以下を提出してください。

1. **ソースコード**
   - 関数の実装（.cファイル）
   - ヘッダファイル（.hファイル）
   - テスト用のmain関数

2. **ドキュメント**
   - 各関数の仕様説明
   - 使用例とサンプル出力
   - エラーケースの説明

3. **テストケース**
   - 正常ケースのテスト
   - 境界値のテスト
   - エラーケースのテスト

## 評価ポイント

- **正確性**: 仕様通りに動作するか
- **安全性**: エラーハンドリングが適切か
- **効率性**: アルゴリズムの計算量は適切か
- **可読性**: コードが理解しやすいか
- **再利用性**: 他のプログラムでも使えるか

## 難易度別の推奨学習順序

### 初学者向け（基本課題から開始）
1. 課題9-1: 基本的な関数作成
2. 課題9-2: 配列操作関数
3. 課題9-3: 文字列処理関数

### 中級者向け（中級課題に挑戦）
4. 課題9-4: 複数戻り値を持つ関数
5. 課題9-5: エラーハンドリング付き関数
6. 課題9-6: 構造体を使った関数

### 上級者向け（上級・挑戦課題）
7. 課題9-7: 再帰関数
8. 課題9-8: 高度な文字列処理
9. 課題9-9: ソートアルゴリズム関数
10. 課題9-10: 関数ポインター
11. 課題9-11: メモリ効率を考慮した関数
12. 課題9-12: 総合プロジェクト

## 学習のヒント

1. **段階的実装**
   - 最初は基本機能のみ実装
   - 動作確認後に機能を追加
   - テストを頻繁に実行

2. **エラーハンドリング**
   - NULLポインターのチェック
   - 配列の境界チェック
   - 無効な引数の処理

3. **関数設計の原則**
   - 単一責任の原則
   - 適切な関数名と引数名
   - const修飾子の活用

4. **テスト駆動開発**
   - 関数作成前にテストケースを考える
   - 境界値のテスト
   - エラーケースのテスト

5. **コードレビュー**
   - 他の人に読んでもらう
   - 改善点を見つける
   - ベストプラクティスを学ぶ

## 参考資料

- C言語関数リファレンス
- アルゴリズムとデータ構造の教科書
- セキュアプログラミングガイド
- 関数型プログラミングの考え方

## 実装例の構成

各課題の実装では以下の構成を推奨します。

```c
// ヘッダーファイル（functions.h）
// - 関数プロトタイプ
// - 定数定義
// - 構造体定義

// 実装ファイル（functions.c）
// - 関数の実装
// - 静的関数（内部使用）
// - エラーハンドリング

// テストファイル（test.c）
// - main関数
// - 各関数のテスト
// - 結果の検証
```

## 発展的な学習内容

1. **可変長引数**
   - va_list、va_start、va_endの使用
   - printfライクな関数の作成

2. **関数ポインター**
   - コールバック関数の実装
   - 関数テーブルの作成

3. **マクロ関数**
   - 関数ライクマクロの作成
   - 条件付きコンパイル

4. **インライン関数**
   - パフォーマンスの最適化
   - 適切な使用場面

このチュートリアルを通じて、C言語の関数について体系的に学習し、実践的なプログラミングスキルを身に付けてください。


# 演習問題を解き終えたら

## 理解度の確認

応用編の演習問題を通じて、以下の点を確認してください：

### ポインタの理解
- [ ] ポインタとアドレスの関係を説明できる
- [ ] ポインタ演算を正しく使える
- [ ] 配列とポインタの関係を理解している

### 文字列処理
- [ ] 文字配列と文字列の違いを理解している
- [ ] 標準ライブラリ関数を適切に使える
- [ ] 独自の文字列処理関数を実装できる

### 関数設計
- [ ] 適切な引数と戻り値を設計できる
- [ ] ポインタ渡しと値渡しを使い分けられる
- [ ] 再帰関数の動作を理解している

## 次のステップ

応用編を修了したら、上級編に進んでください。上級編では、より高度なデータ構造とシステムプログラミングの技術を学びます。

## デバッグのヒント

応用編では、特に以下のエラーに注意してください：

1. **セグメンテーションフォルト**
   - NULLポインタへのアクセス
   - 配列の範囲外アクセス
   - 解放済みメモリへのアクセス

2. **メモリリーク**
   - mallocしたメモリのfree忘れ
   - 適切なメモリ管理

3. **文字列処理のバグ**
   - NULL終端の忘れ
   - バッファオーバーフロー

これらのエラーは、printfデバッグやデバッガを使って丁寧に調査してください。

