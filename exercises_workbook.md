---
title: "C言語プログラミング演習課題集"
author: "プログラミング学習教材"
date: "2024年"
---

# C言語プログラミング演習課題集

## 目次

1. [第1章: C言語入門 - 演習課題](#第1章-c言語入門---演習課題)
2. [第2章: 基本構文 - 演習課題](#第2章-基本構文---演習課題)
3. [第3章: データ型と変数 - 演習課題](#第3章-データ型と変数---演習課題)
4. [第4章: 演算子 - 演習課題](#第4章-演算子---演習課題)
5. [第5章: 条件分岐 - 演習課題](#第5章-条件分岐---演習課題)
6. [第6章: 繰り返し処理 - 演習課題](#第6章-繰り返し処理---演習課題)
7. [第7章: 配列 - 演習課題](#第7章-配列---演習課題)
8. [第8章: 文字列処理 - 演習課題](#第8章-文字列処理---演習課題)
9. [第9章: 関数 - 演習課題](#第9章-関数---演習課題)
10. [第10章: ポインタ - 演習課題](#第10章-ポインタ---演習課題)
11. [第11章: 構造体 - 演習課題](#第11章-構造体---演習課題)
12. [第12章: 関数ポインタ - 演習課題](#第12章-関数ポインタ---演習課題)
13. [第13章: 高度なトピック - 演習課題](#第13章-高度なトピック---演習課題)

---


# 第1章: C言語入門 - 演習課題


## 演習の目的

この演習を通して、C言語の開発環境が正しく構築されているかを確認し、基本的なコンパイル手順を習得します。

## 演習課題

### 基礎問題

#### 問題1: 環境構築確認
サンプルプログラム `examples/environment_check.c` を使用して、以下の作業を実行してください。

1. **C90準拠でコンパイル・実行**
   ```bash
   make c90
   ```

2. **C99準拠でコンパイル・実行**
   ```bash
   make c99
   ```

3. **C11準拠でコンパイル・実行**
   ```bash
   make c11
   ```

4. **C17準拠でコンパイル・実行**
   ```bash
   make c17
   ```

5. **実行結果の確認**
   - 各規格でコンパイルしたプログラムの出力結果を比較してください
   - 規格による違いがあるかを確認してください

#### 問題2: コンパイラ情報の確認
以下のコマンドを実行して、開発環境の情報を調べてください。

1. **コンパイラバージョンの確認**
   ```bash
   gcc --version
   ```

2. **対応規格の確認**
   ```bash
   gcc -std=c90 --help
   gcc -std=c99 --help
   gcc -std=c11 --help
   gcc -std=c17 --help
   ```

3. **プリプロセッサマクロの確認**
   ```bash
   echo | gcc -dM -E -
   ```

#### 問題3: 基本的なプログラム作成
`solutions/ex1_3_hello_name.c` というファイルを作成し、以下の機能を実装してください。

**要求仕様:**
- ユーザーに名前の入力を求める
- 入力された名前を使って挨拶メッセージを表示する
- C90準拠で記述する

**実行例:**
```
あなたの名前を入力してください: 田中
こんにちは、田中さん！
```

### 応用問題

#### 問題4: 規格比較レポート
C90とC99の主な違いについて調べ、以下の点についてまとめてください。

1. **新しく追加されたデータ型**
2. **新しく追加された機能**
3. **プログラムの書き方で変わった点**
4. **組込み開発でC90が使われ続ける理由**

回答は `exercises/standards_comparison.md` に記述してください。

#### 問題5: コンパイル手順の詳細調査
以下のコンパイラオプションを使用して、コンパイル過程を段階的に確認してください。

1. **プリプロセッサ出力の確認**
   ```bash
   gcc -E examples/environment_check.c > preprocessed.i
   ```

2. **アセンブリコード生成**
   ```bash
   gcc -S examples/environment_check.c
   ```

3. **オブジェクトファイル生成**
   ```bash
   gcc -c examples/environment_check.c
   ```

4. **実行ファイル生成**
   ```bash
   gcc environment_check.o -o environment_check
   ```

各段階で生成されるファイルの内容を確認し、`exercises/compilation_report.md` にまとめてください。

#### 問題6: 環境固有情報の調査
以下の情報を調べて、`solutions/ex1_6_system_info.c` プログラムを作成してください。

**表示する情報:**
- 使用しているOS
- コンパイラの種類とバージョン
- CPUアーキテクチャ（32bit/64bit）
- エンディアン（ビッグエンディアン/リトルエンディアン）
- 各データ型のサイズ

## 提出形式

各問題の回答は以下のファイルに記述してください：

- **問題3**: `solutions/ex1_3_hello_name.c`
- **問題4**: `exercises/standards_comparison.md`
- **問題5**: `exercises/compilation_report.md`
- **問題6**: `solutions/ex1_6_system_info.c`

## 評価基準

### 基礎問題
- [ ] 環境確認プログラムが正常にコンパイル・実行できる
- [ ] 各規格でのコンパイルができる
- [ ] ex1_3_hello_name.cが要求仕様を満たしている
- [ ] C90準拠で記述されている

### 応用問題
- [ ] 規格比較が正確に記述されている
- [ ] コンパイル手順が理解できている
- [ ] 環境固有情報の取得ができている
- [ ] レポートが詳細で分かりやすい

## 参考資料

- [GCC公式ドキュメント](https://gcc.gnu.org/documentation.html)
- [C言語規格書](https://www.iso.org/standard/74528.html)
- [GNU Make マニュアル](https://www.gnu.org/software/make/manual/)

## 次の段階

演習課題が完了したら、[基本文法・Hello World](../../basics-syntax/README.md) に進んでください。
---

# 第2章: 基本構文 - 演習課題


## 基礎課題

### 課題2-1: 基本的な出力
プログラムを作成して以下を出力してください：
```
こんにちは、C言語の世界へ！
私の名前は [あなたの名前] です。
今日からプログラミングを始めます。
```

**要求事項:**
- `printf`関数を使用すること
- 適切なエスケープシーケンスを使用すること
- [あなたの名前]の部分は実際の名前に置き換えること

**ファイル名:** `ex2_1_hello_intro.c`

---

### 課題2-2: 変数と基本データ型
以下の変数を定義し、値を代入して出力するプログラムを作成してください：

**変数一覧:**
- 整数型: 年齢（例：25）
- 浮動小数点型: 身長（例：170.5）
- 文字型: 血液型（例：'A'）
- 整数型: 好きな数字（例：7）

**出力例:**
```
=== 自己紹介データ ===
年齢: 25歳
身長: 170.5cm
血液型: A型
好きな数字: 7
================
```

**要求事項:**
- 適切なデータ型を選択すること
- `printf`の書式指定子を正しく使用すること
- コメントで各変数の説明を記述すること

**ファイル名:** `ex2_2_personal_data.c`

---

### 課題2-3: 入力と出力
ユーザーから名前と年齢を入力してもらい、それを使って計算結果を表示するプログラムを作成してください。

**機能:**
1. 名前を入力してもらう
2. 年齢を入力してもらう
3. 10年後の年齢を計算する
4. 結果を表示する

**出力例:**
```
お名前を入力してください: 田中太郎
年齢を入力してください: 25

こんにちは、田中太郎さん！
現在の年齢: 25歳
10年後の年齢: 35歳
プログラミングの学習、頑張ってください！
```

**要求事項:**
- `scanf`関数を使用すること
- 適切なバッファサイズを設定すること
- 計算結果を変数に保存すること

**ファイル名:** `ex2_3_age_calculator.c`

---

## 応用課題

### 課題2-4: 書式指定子の練習
様々な書式指定子を使って、数値を異なる形式で表示するプログラムを作成してください。

**表示する数値:** `123`, `3.14159`, `255`

**出力例:**
```
=== 書式指定子のデモ ===
整数 123 の表示:
  10進数: 123
  16進数: 7b
  8進数: 173
  フィールド幅5: |  123|
  ゼロ埋め: |00123|

実数 3.14159 の表示:
  デフォルト: 3.14159
  小数点以下2桁: 3.14
  指数表記: 3.14159e+00
  フィールド幅10.2: |      3.14|

文字コード 255:
  文字として: ÿ
  16進数: ff
  10進数: 255
====================
```

**要求事項:**
- 各種書式指定子を使用すること（%d, %x, %o, %f, %e, %c など）
- フィールド幅とゼロ埋めを実演すること
- 適切なコメントを記述すること

**ファイル名:** `ex2_4_format_demo.c`

---

### 課題2-5: 簡単な計算機
四則演算を実行する簡単な計算機プログラムを作成してください。

**機能:**
1. 2つの数値を入力してもらう
2. 四則演算（+, -, *, /）の結果を表示する
3. 割り算では整数除算と実数除算の両方を表示する

**出力例:**
```
簡単な計算機プログラム
===================
第1の数値を入力してください: 7
第2の数値を入力してください: 2

計算結果:
  7 + 2 = 9
  7 - 2 = 5
  7 * 2 = 14
  7 / 2 = 3 (整数除算)
  7 / 2 = 3.50 (実数除算)
```

**要求事項:**
- 整数除算と実数除算を区別すること
- ゼロ除算のチェックは不要（基礎課題のため）
- 適切な変数名を使用すること

**ファイル名:** `ex2_5_simple_calculator.c`

---

## 挑戦課題

### 課題2-6: 文字とASCIIコード
文字とASCIIコードの関係を学ぶプログラムを作成してください。

**機能:**
1. ユーザーから文字を入力してもらう
2. その文字のASCIIコードを表示する
3. ASCIIコード表の一部を表示する

**出力例:**
```
文字を1つ入力してください: A
入力された文字: A
ASCIIコード: 65

ASCII表（32-126）の一部:
 32:    33: !  34: "  35: #  36: $  37: %  38: &  39: '
 40: (  41: )  42: *  43: +  44: ,  45: -  46: .  47: /
 48: 0  49: 1  50: 2  51: 3  52: 4  53: 5  54: 6  55: 7
 56: 8  57: 9  58: :  59: ;  60: <  61: =  62: >  63: ?
 64: @  65: A  66: B  67: C  68: D  69: E  70: F  71: G
```

**要求事項:**
- `getchar()`または`scanf(" %c", &ch)`を使用すること
- ループを使ってASCII表を表示すること
- 適切な書式で表を整列させること

**ファイル名:** `ex2_6_ascii_explorer.c`

---

## 提出について

### ファイル構成
```
solutions/
├── ex2_1_hello_intro.c
├── ex2_2_personal_data.c
├── ex2_3_age_calculator.c
├── ex2_4_format_demo.c
├── ex2_5_simple_calculator.c
└── ex2_6_ascii_explorer.c
```

### コンパイルと実行
```bash
# コンパイル例
gcc -o hello_intro ex2_1_hello_intro.c
gcc -o personal_data ex2_2_personal_data.c
gcc -o age_calculator ex2_3_age_calculator.c

# 実行例
./hello_intro
./personal_data
./age_calculator
```

### 評価ポイント
1. **基本文法**: 正しいC言語の文法で記述されているか
2. **コーディング規約**: 適切なインデント、変数名、コメントが使用されているか
3. **機能性**: 要求された機能が正しく実装されているか
4. **入出力**: printf/scanfが適切に使用されているか
5. **書式指定**: 適切な書式指定子が使用されているか

### 学習のポイント
- C言語の基本的な入出力方法
- 変数の宣言と初期化
- 基本データ型の理解
- 書式指定子の使い方
- コメントの書き方
- プログラムの基本構造

頑張って取り組んでください！

---

# 第3章: データ型と変数 - 演習課題


## 基礎問題

### 演習3-1. 変数宣言と初期化

さまざまなデータ型の変数を宣言し、初期化して値を表示するプログラムを作成してください。

**要件:**
- 各基本データ型（char, short, int, long, float, double）の変数を宣言
- 適切な値で初期化
- printf関数で型に応じた書式指定子を使用して出力
- 符号付き・符号なしの両方を含める

**期待される出力例:**
```
char型: 文字 = 'A', 値 = 65
unsigned char型: 値 = 255
short型: 値 = -1000
unsigned short型: 値 = 65535
int型: 値 = -123456
unsigned int型: 値 = 4294967295
float型: 値 = 3.14159
double型: 値 = 3.141592653589793
```

### 演習3-2. 四則演算計算機

2つの数値を変数に格納し、四則演算（加算、減算、乗算、除算）の結果を表示するプログラムを作成してください。

**要件:**
- 整数型と浮動小数点型の両方で実装
- 除算では整数除算と実数除算の違いを表示
- 各演算結果を見やすく表示

### 演習3-3. データ型サイズの確認

sizeof演算子を使って、各データ型のサイズを表示するプログラムを作成してください。

**要件:**
- 基本データ型すべてのサイズを表示
- 配列のサイズも確認
- ポインタのサイズも確認
- サイズをバイト単位で表示

## 応用問題

### 演習3-4. 型変換の理解

整数除算と実数除算の違い、および暗黙的・明示的型変換を確認するプログラムを作成してください。

**要件:**
- 同じ数値で整数除算と実数除算を実行し、結果を比較
- 暗黙的型変換が発生する例を実装
- 明示的型変換（キャスト）を使用した例を実装
- 精度の損失が発生する例を示す

### 演習3-5. スコープの実験

グローバル変数、ローカル変数、静的変数を使い分けるプログラムを作成してください。

**要件:**
- 同じ名前の変数を異なるスコープで宣言
- スコープの隠蔽（シャドウイング）を実演
- 静的変数を使ったカウンター関数を実装
- 各変数の値の変化を追跡して表示

### 演習3-6. 定数の活用

constと#defineを使って定数を定義し、円の面積と円周を計算するプログラムを作成してください。

**要件:**
- 円周率をconstと#defineの両方で定義
- 半径を入力として受け取る
- 面積と円周を計算して表示
- 定数を変更しようとした場合のエラーを確認（コメントで説明）

## チャレンジ問題

### 温度変換プログラム

摂氏・華氏・ケルビンの温度単位を相互変換するプログラムを作成してください。

**要件:**
- 変換式で使用する定数を適切に定義
- 浮動小数点演算の精度に注意
- ユーザーフレンドリーな入出力
- 変換公式：
  - 華氏 = 摂氏 × 9/5 + 32
  - ケルビン = 摂氏 + 273.15

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex3_1_variables.c`, `ex3_2_calculator.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex_variables.c -o ex_variables
./ex_variables
```

## ヒント

- printf関数の書式指定子を正しく使用する
  - %d: int
  - %u: unsigned int
  - %ld: long
  - %f: float/double
  - %c: char
- 初期化されていない変数の使用に注意
- 型の範囲を超えないよう注意
- sizeof演算子の戻り値はsize_t型（%luで出力）
---

# 第4章: 演算子 - 演習課題


## 基礎問題

### 演習4-1: 四則演算計算機

2つの整数を入力として受け取り、すべての算術演算（加算、減算、乗算、除算、剰余）の結果を表示するプログラムを作成してください。

**要件:**
- ユーザーから2つの整数を入力
- 各演算の結果を見やすく表示
- ゼロ除算のチェックを含める

**期待される出力例:**
```
2つの整数を入力してください: 10 3
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
```

### 演習4-2: 比較と論理演算

2つの整数を入力として受け取り、関係演算子と論理演算子を使って最大値と最小値を求めるプログラムを作成してください。

**要件:**
- 2つの整数を入力
- if文を使わず、条件演算子（三項演算子）のみで実装
- 最大値と最小値を表示

### 演習4-3: インクリメント・デクリメント

前置と後置のインクリメント・デクリメント演算子の違いを確認するプログラムを作成してください。

**要件:**
- 変数に対して前置・後置の両方を使用
- 各操作後の値を表示
- 式の中での動作も確認

## 応用問題

### 演習4-4: ビット操作

整数を入力として受け取り、その数値の各ビットを表示し、特定のビット操作を実行するプログラムを作成してください。

**要件:**
- 2進数表示
- 指定したビット位置のON/OFF確認
- 特定ビットの設定・クリア・トグル機能

### 演習4-5: 条件演算子の活用

3つの数値を入力として受け取り、条件演算子（三項演算子）のみを使って昇順に並び替えるプログラムを作成してください。

**要件:**
- if文、switch文を使用しない
- 条件演算子のネストを活用
- 並び替えた結果を表示

### 演習4-6: 演算子優先順位

複雑な式を含むプログラムを作成し、演算子の優先順位による計算結果の違いを確認してください。

**要件:**
- 同じ数値で異なる式を評価
- 括弧の有無による結果の違いを表示
- 少なくとも3種類以上の演算子を使用

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex4_1_calculator.c`, `ex4_2_comparison.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex4_1_calculator.c -o ex4_1_calculator
./ex4_1_calculator
```

## ヒント

- 演算子の優先順位に注意
- ゼロ除算やオーバーフローに対する考慮
- 可読性を意識したコードを心がける
- 適切なコメントを追加する
---

# 第5章: 条件分岐 - 演習課題


## 演習の目的
- if文、switch文の理解を深める
- 条件演算子の適切な使い方を習得する
- 複雑な条件分岐の設計力を養う

## 演習問題

### 演習4-1: 年齢による料金計算
映画館の料金システムを実装してください。

**要件:**
- 3歳未満: 無料
- 3歳以上12歳以下: 子供料金（800円）
- 13歳以上18歳以下: 学生料金（1200円）
- 19歳以上65歳以下: 大人料金（1800円）
- 66歳以上: シニア料金（1200円）

**実装のヒント:**
- if-else if文を使用
- 境界値に注意

### 演習4-2: 電卓プログラム
四則演算ができる簡単な電卓を作成してください。

**要件:**
- ユーザーから2つの数値と演算子（+, -, *, /）を入力
- switch文を使って演算を実行
- ゼロ除算のエラー処理を含める

**実装のヒント:**
- 演算子は char 型で受け取る
- 除算の場合は分母が0でないかチェック

### 演習4-3: BMI判定プログラム
身長と体重からBMIを計算し、判定するプログラムを作成してください。

**要件:**
- BMI = 体重(kg) / (身長(m) × 身長(m))
- BMI判定基準:
  - 18.5未満: 低体重
  - 18.5以上25未満: 標準体重
  - 25以上30未満: 肥満度1
  - 30以上: 肥満度2

**実装のヒント:**
- 身長はセンチメートルで入力してメートルに変換
- 浮動小数点数を使用

### 演習4-4: うるう年判定
西暦年を入力してうるう年かどうか判定するプログラムを作成してください。

**うるう年の条件:**
1. 4で割り切れる年はうるう年
2. ただし、100で割り切れる年は平年
3. ただし、400で割り切れる年はうるう年

**実装のヒント:**
- 複数の条件を論理演算子で組み合わせる
- 条件の順序に注意

### 演習4-5: 成績評価システム
複数の科目の点数から総合評価を出すプログラムを作成してください。

**要件:**
- 3科目（国語、数学、英語）の点数を入力
- 平均点を計算
- 平均点による評価（A〜F）
- 全科目60点以上の場合のみ「合格」、それ以外は「不合格」
- 条件演算子を使って簡潔に表示

**実装のヒント:**
- 平均点の計算は整数演算に注意
- 複数の条件を組み合わせる

## チャレンジ問題

### チャレンジ4-6: じゃんけんゲーム
コンピュータとじゃんけんをするプログラムを作成してください。

**要件:**
- ユーザーの手を数値で入力（1:グー、2:チョキ、3:パー）
- コンピュータの手はランダムに決定
- 勝敗を判定して表示
- 不正な入力のチェック

**追加要件:**
- 3回勝負で最終的な勝者を決定
- 各1回の結果を記録して最後に表示

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex4_1.c`, `ex4_2.c` のような形式で
3. コメントで問題番号と簡単な説明を記載
4. コンパイル・実行確認を必ず実行う

## 期限
演習問題は次の章に進む前に完了させましょう。
---

# 第6章: 繰り返し処理 - 演習課題


## 演習の目的
- for文、while文、do-while文の使い分けを理解する
- break文とcontinue文を適切に使えるようになる
- ネストしたループを活用した問題解決能力を養う

## 演習問題

### 演習5-1: フィボナッチ数列
最初のN個のフィボナッチ数を表示するプログラムを作成してください。

**要件:**
- ユーザーから表示する個数Nを入力
- フィボナッチ数列: 0, 1, 1, 2, 3, 5, 8, 13, ...
- for文を使用して実装

**実装のヒント:**
- 最初の2つの数は0と1
- 3番目以降は前の2つの数の和

### 演習5-2: 数当てゲーム（改良版）
1から100までの数当てゲームを作成してください。

**要件:**
- プログラムがランダムに1～100の数を決定
- ユーザーが予想を入力
- 「もっと大きい」「もっと小さい」のヒントを出す
- 10回以内に当てられなければゲームオーバー
- do-while文を使用

**実装のヒント:**
- `rand() % 100 + 1` でランダムな数を生成
- 試行回数をカウント

### 演習5-3: 素数リスト
指定された範囲内のすべての素数を表示するプログラムを作成してください。

**要件:**
- ユーザーから範囲（開始値と終了値）を入力
- その範囲内の素数をすべて表示
- 素数の個数も表示
- ネストしたループとbreak文を活用

**実装のヒント:**
- 2からsqrt(n)まで割り切れるか確認
- 効率化のため、偶数は2以外スキップ

### 演習5-4: 図形の描画
アスタリスク(*)を使って様々な図形を描画するプログラムを作成してください。

**要件:**
以下の4つの図形を描画する機能を実装:
1. 正方形
2. 直角三角形
3. 逆直角三角形
4. ダイヤモンド

**例（サイズ5の場合）:**

正方形:
```
*****
*****
*****
*****
*****
```

直角三角形:
```
*
**
***
****
*****
```

逆直角三角形:
```
*****
****
***
**
*
```

ダイヤモンド:
```
  *
 ***
*****
 ***
  *
```

**実装のヒント:**
- ネストしたループを使用
- 空白文字とアスタリスクの配置に注意

### 演習5-5: 掛け算表
9×9の掛け算表を表示するプログラムを作成してください。

**要件:**
- ネストしたfor文を使用
- 見やすい表形式で出力
- 列と行のヘッダーを含める

**実装のヒント:**
- printf()の書式指定子で桁揃えを行う
- %3d などを使用して桁数を統一

### 演習5-6: 階乗計算
ユーザーから入力された数の階乗を計算するプログラムを作成してください。

**要件:**
- ユーザーから正の整数を入力
- その数の階乗を計算して表示
- while文を使用して実装
- オーバーフローに注意

**実装のヒント:**
- n! = n × (n-1) × (n-2) × ... × 1
- long long型の使用を検討

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex5_1.c`, `ex5_2.c` のような形式で
3. コメントで問題番号と簡単な説明を記載
4. コンパイル・実行確認を必ず実行

## 期限
演習問題は次の章に進む前に完了させましょう。
---

# 第7章: 配列 - 演習課題


## 演習の目的
- 1次元配列と多次元配列の理解を深める
- 文字列配列の扱い方を習得する
- 配列を使った実践的な問題解決能力を養う

## 演習問題

### 演習6-1: 配列の基本操作 
整数配列に対する各種操作を実行するプログラムを作成してください。

**要件:**
- 5個の整数を入力して配列に格納
- 以下の操作を実装:
  - 配列の全要素を表示
  - 最大値と最小値を見つける
  - 平均値を計算
  - 配列を逆順に並べ替える
  - 指定した値が配列内に存在するか検索

**実装のヒント:**
- 配列のサイズは#defineで定義
- 逆順は別の配列にコピーまたはその場で交換

### 演習6-2: 成績管理システム 
複数の学生の複数科目の成績を管理するプログラムを作成してください。

**要件:**
- 5人の学生、4科目（国語、数学、英語、理科）の成績を2次元配列で管理
- 各学生の合計点と平均点を計算
- 各科目の平均点を計算
- 最高得点の学生と科目を表示
- 成績表を見やすく表示

**実装のヒント:**
- 2次元配列 grades[][] を使用
- 行が学生、列が科目

### 演習6-3: 文字列配列の操作 
都道府県名を管理するプログラムを作成してください。

**要件:**
- 10個の都道府県名を文字列配列に格納
- 以下の機能を実装:
  - 全都道府県名をアルファベット順に表示
  - 文字数が最も長い都道府県名を見つける
  - 指定した文字で始まる都道府県名を検索
  - 都道府県名に「県」が含まれるものをカウント

**実装のヒント:**
- char prefecture[][] またはchar *prefecture[] を使用
- strcmp()関数で文字列比較

### 演習6-4: 行列演算
2次元配列を使って行列演算を実行するプログラムを作成してください。

**要件:**
- 3x3の行列を2つ入力
- 以下の演算を実装:
  - 行列の加算
  - 行列の減算
  - 行列の乗算
  - 転置行列の計算

**実装のヒント:**
- 行列の乗算: result[i][j] = Σ(a[i][k] * b[k][j])
- 各演算結果を見やすく表示

### 演習6-5: 簡易辞書プログラム 
英単語と日本語訳のペアを管理する辞書プログラムを作成してください。

**要件:**
- 英単語と日本語訳のペアを10個程度登録
- 以下の機能を実装:
  - 英単語を入力すると日本語訳を表示
  - 日本語を入力すると英単語を表示
  - 登録されている全単語を一覧表示
  - 単語の追加機能（配列に空きがある場合）

**実装のヒント:**
- 2つの文字列配列（英語用と日本語用）を使用
- または構造体の配列を使用（先取り）

## チャレンジ問題

### チャレンジ6-1: ソートアルゴリズムの実装
配列のソートアルゴリズムを複数実装して比較してください。

**要件:**
- 以下のソートアルゴリズムを実装:
  - バブルソート
  - 選択ソート
  - 挿入ソート
- 各アルゴリズムの実行時間を測定
- ランダムな配列、ソート済み配列、逆順配列で性能比較

**追加要件:**
- 比較回数と交換回数をカウント
- 結果をグラフィカルに表示（*を使った簡易グラフ）

### チャレンジ6-2: ライフゲーム（Conway's Game of Life）
セル・オートマトンの一種であるライフゲームを実装してください。

**要件:**
- 20x20のグリッドで実装
- 初期パターンを設定可能
- 以下のルールを実装:
  - 生きているセルの周囲に2-3個の生きたセルがあれば生存
  - 死んでいるセルの周囲にちょうど3個の生きたセルがあれば誕生
  - それ以外は死亡
- 世代を進めるごとに画面をクリアして表示

**実装のヒント:**
- 2つの2次元配列を使用（現在と次世代）
- 境界条件の処理に注意

## 提出方法
1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex6_1.c`, `ex6_2.c` のような形式で
3. 配列のサイズや境界チェックに特に注意
4. メモリアクセスエラーが起きないよう十分にテスト

## 期限
配列は多くのプログラムの基礎となるデータ構造です。
しっかりと理解してから次の章へ進みましょう。
---

# 第8章: 文字列処理 - 演習課題


この章では、C言語における文字列操作の基本から応用まで、段階的に学習できる演習問題を提供しています。

## 演習の概要

文字列処理は、プログラミングにおいて最も基本的かつ重要な技術の一つです。この演習では、以下の3つの段階で文字列操作を習得します。

### 学習目標

1. **基本的な文字列操作の理解**
   - null終端文字列の概念
   - ポインタと配列の関係
   - メモリ安全な文字列操作

2. **文字列配列の管理**
   - 二次元配列の操作
   - 動的な要素の追加・削除
   - ソートと検索アルゴリズム

3. **高度な文字列処理**
   - パターンマッチング
   - アルゴリズムの最適化
   - 実用的な応用例

## 演習問題一覧

### 演習8-1: 基本的な文字列操作

**難易度**: 初級  
**所要時間**: 2-3時間

標準ライブラリの関数を使わずに、基本的な文字列操作関数を実装します。

**実装する関数**:
1. `my_strlen()` - 文字列の長さを計算
2. `my_strcpy()` - 文字列をコピー
3. `my_strcmp()` - 文字列を比較
4. `my_strcat()` - 文字列を連結
5. `my_strchr()` - 文字を検索
6. `my_strrchr()` - 文字を後方検索
7. `count_char()` - 特定文字をカウント

**学習ポイント**:
- null終端文字列の仕組み
- ポインタ演算の基礎
- バッファオーバーフロー対策
- エラーハンドリング

### 演習8-2: 文字列配列の管理

**難易度**: 中級  
**所要時間**: 3-4時間

学生名を格納する文字列配列の管理システムを実装します。

**実装する機能**:
1. **配列管理機能**
   - 学生名の追加・削除
   - 重複チェック
   - 配列の動的管理

2. **検索とソート機能**
   - 名前による検索
   - アルファベット順ソート
   - 一覧表示機能

**学習ポイント**:
- 二次元配列の操作
- 配列要素の挿入・削除
- バブルソートアルゴリズム
- 線形検索の実装

### 演習8-3: 高度な文字列検索

**難易度**: 上級  
**所要時間**: 4-6時間

標準ライブラリを使わずに、高度な文字列検索機能を実装します。

**実装する機能**:
1. **検索機能**
   - 大小文字を区別しない検索
   - 単語境界での検索
   - 部分文字列検索

2. **パターンマッチング**
   - ワイルドカード検索（*、?）
   - 複数パターンの同時検索
   - 検索結果の詳細情報

**学習ポイント**:
- 高度な文字列マッチングアルゴリズム
- メモリ効率的な実装
- 動的プログラミング
- パフォーマンス最適化

## 提出要件

各演習について、以下の要件を満たしてください：

### 必須要件

1. **ソースコード**
   - 適切なコメント（日本語）
   - 関数の詳細な説明
   - エラーハンドリング

2. **テストプログラム**
   - 各関数の動作確認
   - 境界値テスト
   - エラーケースのテスト

3. **実行例**
   - 正常ケースの実行結果
   - エラーケースの実行結果

### 推奨要件

1. **コーディングスタイル**
   - 一貫したインデント
   - 意味のある変数名
   - 適切な関数分割

2. **安全性**
   - バッファオーバーフロー対策
   - NULLポインタチェック
   - メモリリークの防止

## 評価基準

### 正確性 (40%)
- 仕様通りに動作するか
- エラーケースが適切に処理されるか
- テストケースが網羅的か

### 安全性 (30%)
- バッファオーバーフローがないか
- メモリ管理が適切か
- 入力検証が十分か

### 効率性 (20%)
- アルゴリズムの計算量が適切か
- 不要な処理がないか
- メモリ使用量が最適か

### 可読性 (10%)
- コードが理解しやすいか
- コメントが適切か
- 命名規則が一貫しているか

## 学習の進め方

### 推奨手順

1. **基礎の理解**
   - 文字列の基本概念を復習
   - ポインタと配列の関係を確認
   - null終端文字列の仕組みを理解

2. **段階的実装**
   - 演習1から順番に取り組む
   - 小さな関数から実装開始
   - テストケースを先に作成

3. **デバッグとテスト**
   - コンパイル時の警告を確認
   - 実行時エラーをチェック
   - メモリ使用状況を監視

4. **最適化と改善**
   - パフォーマンスを測定
   - コードの可読性を向上
   - エラーハンドリングを強化

### 学習のヒント

1. **安全第一**
   - 配列の境界を常に確認
   - NULLポインタをチェック
   - バッファサイズを適切に管理

2. **テスト駆動**
   - 関数作成前にテストケースを考える
   - エッジケースを忘れずに
   - 段階的に機能を拡張

3. **効率性の考慮**
   - 不要な文字列コピーを避ける
   - ポインタ操作を活用
   - メモリ使用量を最適化

## トラブルシューティング

### よくある問題

1. **セグメンテーション違反**
   - 配列の境界越え
   - null終端の忘れ
   - 未初期化ポインタ

2. **予期しない出力**
   - null終端文字の扱い
   - 文字コードの問題
   - バッファの不足

3. **メモリリーク**
   - 動的メモリの解放忘れ
   - 重複した確保
   - 例外時の処理不備

### デバッグ方法

1. **printfデバッグ**
   - 変数の値を確認
   - 関数の呼び出し順序を追跡
   - 配列の内容を表示

2. **gdbの使用**
   - ブレークポイントの設定
   - ステップ実行
   - 変数の監視

3. **静的解析ツール**
   - コンパイラの警告
   - lintツールの使用
   - メモリチェッカー

## 参考資料

### 必読資料
- [文字列操作の基礎](../README.md)
- [実装例とサンプルコード](../examples/)
- [解答例](../solutions/)

### 推奨図書
- 『プログラミング言語C 第2版』（K&R）
- 『Cプログラミング専門課程』
- 『セキュアプログラミング講座』

### オンラインリソース
- C言語標準ライブラリリファレンス
- 文字列処理アルゴリズム
- セキュアコーディング標準

---

これらの演習を通じて、C言語における文字列操作の基礎から応用まで、体系的に学習することができます。各演習に丁寧に取り組み、安全で効率的なコードの作成技術を身につけてください。
---

# 第9章: 関数 - 演習課題


## 基本課題

### 課題9-1: 基本的な関数作成
以下の関数を作成してください：

1. **数学関数**
   - 2つの整数の最大値を返す関数 `int max(int a, int b)`
   - 3つの整数の最小値を返す関数 `int min(int a, int b, int c)`
   - 数値が偶数かどうかを判定する関数 `int is_even(int n)`
   - 数値が素数かどうかを判定する関数 `int is_prime(int n)`

2. **文字・文字列関数**
   - 文字が英字かどうかを判定する関数 `int is_letter(char c)`
   - 文字列の長さを計算する関数 `int my_strlen(const char str[])`
   - 文字列内の特定文字を数える関数 `int count_char(const char str[], char ch)`

3. **表示関数**
   - 指定した長さの線を描く関数 `void draw_line(int length, char ch)`
   - 数値を指定した桁数で表示する関数 `void print_number_padded(int num, int width)`

### 課題9-2: 配列操作関数
以下の配列操作関数を作成してください：

1. **基本操作**
   - 配列の要素の合計を計算する関数 `int array_sum(int arr[], int size)`
   - 配列の平均値を計算する関数 `double array_average(int arr[], int size)`
   - 配列内の最大値のインデックスを返す関数 `int find_max_index(int arr[], int size)`

2. **検索・ソート**
   - 線形検索関数 `int linear_search(int arr[], int size, int target)`
   - 配列を昇順にソートする関数 `void sort_array(int arr[], int size)`
   - 配列の要素を逆順にする関数 `void reverse_array(int arr[], int size)`

3. **配列統計**
   - 配列の最大値と最小値を同時に求める関数 `void find_min_max(int arr[], int size, int *min, int *max)`
   - 配列内の重複する要素の数を数える関数 `int count_duplicates(int arr[], int size)`

### 課題9-3: 文字列処理関数
以下の文字列処理関数を作成してください：

1. **基本処理**
   - 文字列をコピーする関数 `void my_strcpy(char dest[], const char src[])`
   - 文字列を連結する関数 `void my_strcat(char dest[], const char src[])`
   - 文字列を比較する関数 `int my_strcmp(const char str1[], const char str2[])`

2. **変換処理**
   - 文字列を大文字に変換する関数 `void to_uppercase(char str[])`
   - 文字列を小文字に変換する関数 `void to_lowercase(char str[])`
   - 文字列を逆順にする関数 `void reverse_string(char str[])`

3. **解析処理**
   - 文字列内の単語数を数える関数 `int count_words(const char str[])`
   - 文字列が回文かどうかを判定する関数 `int is_palindrome(const char str[])`
   - 文字列内の母音の数を数える関数 `int count_vowels(const char str[])`

## 中級課題

### 課題9-4: 複数戻り値を持つ関数
以下の関数を作成してください：

1. **時間計算**
   - 秒数を時分秒に変換する関数 `void seconds_to_hms(int total_seconds, int *hours, int *minutes, int *seconds)`
   - 日数から年月日に変換する関数（365日/年として） `void days_to_ymd(int total_days, int *years, int *months, int *days)`

2. **座標計算**
   - 2点間の距離と中点を計算する関数 `void calculate_line_info(double x1, double y1, double x2, double y2, double *distance, double *mid_x, double *mid_y)`
   - 円の面積と周囲の長さを計算する関数 `void calculate_circle_info(double radius, double *area, double *circumference)`

3. **統計計算**
   - 配列の統計情報を計算する関数 `void calculate_statistics(int arr[], int size, int *min, int *max, double *mean, double *median)`
   - 成績から評価を計算する関数 `void calculate_grade_info(int scores[], int count, double *average, char *grade, int *pass_count)`

### 課題9-5: エラーハンドリング付き関数
安全性を考慮した以下の関数を作成してください：

1. **安全な基本操作**
   - 安全な除算関数 `int safe_divide(double a, double b, double *result)`
   - 安全な配列アクセス関数 `int safe_array_get(int arr[], int size, int index, int *value)`
   - 安全な文字列コピー関数 `int safe_strcpy(char dest[], int dest_size, const char src[])`

2. **範囲チェック付き関数**
   - 範囲指定付きランダム数生成関数 `int random_range(int min, int max, int *result)`
   - 配列の範囲チェック付き設定関数 `int safe_array_set(int arr[], int size, int index, int value)`

3. **バリデーション関数**
   - 文字列が数値として有効かチェックする関数 `int is_valid_number(const char str[])`
   - メールアドレスの基本形式をチェックする関数 `int is_valid_email(const char email[])`

### 課題9-6: 構造体を使った関数
以下の構造体を使った関数を作成してください：

```c
typedef struct {
    double x;
    double y;
} Point;

typedef struct {
    int id;
    char name[50];
    int age;
    double score;
} Student;

typedef struct {
    int year;
    int month;
    int day;
} Date;
```

1. **座標操作**
   - 2点間の距離を計算する関数 `double point_distance(Point p1, Point p2)`
   - 点を移動する関数 `Point move_point(Point p, double dx, double dy)`
   - 複数の点の重心を計算する関数 `Point calculate_centroid(Point points[], int count)`

2. **学生情報処理**
   - 学生情報を表示する関数 `void print_student(Student s)`
   - 学生の成績を更新する関数 `void update_score(Student *s, double new_score)`
   - 学生配列から最高得点者を見つける関数 `Student find_best_student(Student students[], int count)`

3. **日付操作**
   - 日付を表示する関数 `void print_date(Date d)`
   - 日付の妥当性をチェックする関数 `int is_valid_date(Date d)`
   - 2つの日付の差を計算する関数 `int date_difference(Date d1, Date d2)`

## 上級課題

### 課題9-7: 再帰関数
以下の再帰関数を作成してください：

1. **数学的再帰**
   - 階乗を計算する再帰関数 `long factorial_recursive(int n)`
   - フィボナッチ数列を計算する再帰関数 `int fibonacci_recursive(int n)`
   - ユークリッドの互除法による最大公約数を求める再帰関数 `int gcd_recursive(int a, int b)`

2. **文字列再帰**
   - 文字列が回文かどうか再帰的に判定する関数 `int is_palindrome_recursive(const char str[], int start, int end)`
   - 文字列を再帰的に逆順にする関数 `void reverse_string_recursive(char str[], int start, int end)`

3. **配列再帰**
   - 配列の合計を再帰的に計算する関数 `int array_sum_recursive(int arr[], int size)`
   - 配列の最大値を再帰的に見つける関数 `int find_max_recursive(int arr[], int size)`

### 課題9-8: 高度な文字列処理
以下の高度な文字列処理関数を作成してください：

1. **文字列解析**
   - 文字列をトークンに分割する関数 `int tokenize(char str[], char tokens[][50], char delimiter)`
   - 文字列内の括弧の対応をチェックする関数 `int check_brackets(const char str[])`
   - 文字列から数値を抽出する関数 `int extract_numbers(const char str[], int numbers[], int max_count)`

2. **パターンマッチング**
   - 簡単なワイルドカード（*、?）パターンマッチング関数 `int wildcard_match(const char str[], const char pattern[])`
   - 文字列の置換関数 `int string_replace(char str[], const char old_substr[], const char new_substr[])`

3. **文字列フォーマット**
   - 文字列を指定幅で中央揃えする関数 `void center_string(char result[], const char str[], int width)`
   - CSV形式の文字列を解析する関数 `int parse_csv_line(const char line[], char fields[][100], int max_fields)`

### 課題9-9: ソートアルゴリズム関数
以下のソートアルゴリズムを関数として実装してください：

1. **基本ソート**
   - バブルソート `void bubble_sort(int arr[], int size)`
   - 選択ソート `void selection_sort(int arr[], int size)`
   - 挿入ソート `void insertion_sort(int arr[], int size)`

2. **高速ソート**
   - マージソート `void merge_sort(int arr[], int left, int right)`
   - クイックソート `void quick_sort(int arr[], int left, int right)`

3. **特殊ソート**
   - 文字列配列のソート `void sort_strings(char strings[][100], int count)`
   - 構造体配列のソート（複数キー対応）`void sort_students(Student students[], int count, int sort_by)`

## 挑戦課題

### 課題9-10: 関数ポインター
以下の関数ポインターを使った課題に取り組んでください：

1. **計算機関数**
   - 四則演算を関数ポインターで切り替える計算機 `double calculator(double a, double b, double (*operation)(double, double))`
   - 配列に対する処理を関数ポインターで指定する関数 `void process_array(int arr[], int size, void (*processor)(int*))`

2. **ソート関数の汎用化**
   - 比較関数を引数に取る汎用ソート関数 `void generic_sort(void *arr, int size, int elem_size, int (*compare)(const void*, const void*))`

3. **コールバック関数**
   - イベント処理システム `void register_callback(int event_type, void (*callback)(int))`

### 課題9-11: メモリ効率を考慮した関数
メモリ使用量を最適化した関数を作成してください：

1. **動的メモリ管理**
   - 動的配列を管理する関数群
   - 文字列プールを管理する関数群
   - メモリリークを検出する関数

2. **効率的なアルゴリズム**
   - インプレース（元の配列内で処理）ソート関数
   - メモリ使用量を抑えた文字列処理関数
   - キャッシュ効率を考慮した配列処理関数

### 課題9-12: 総合プロジェクト
複数の関数を組み合わせた総合的なプロジェクトを作成してください：

1. **学生管理システム**
   - 学生情報の登録、検索、更新、削除機能
   - 成績統計の計算機能
   - データのファイル保存・読み込み機能

2. **テキスト解析ツール**
   - ファイルの読み込みと解析
   - 単語頻度の統計
   - 文字列パターンの検索

3. **数値計算ライブラリ**
   - 行列演算機能
   - 統計計算機能
   - 数値積分・微分機能

## 提出要件

各課題について、以下を提出してください：

1. **ソースコード**
   - 関数の実装（.cファイル）
   - ヘッダファイル（.hファイル）
   - テスト用のmain関数

2. **ドキュメント**
   - 各関数の仕様説明
   - 使用例とサンプル出力
   - エラーケースの説明

3. **テストケース**
   - 正常ケースのテスト
   - 境界値のテスト
   - エラーケースのテスト

## 評価ポイント

- **正確性**: 仕様通りに動作するか
- **安全性**: エラーハンドリングが適切か
- **効率性**: アルゴリズムの計算量は適切か
- **可読性**: コードが理解しやすいか
- **再利用性**: 他のプログラムでも使えるか

## 難易度別の推奨学習順序

### 初学者向け（基本課題から開始）
1. 課題9-1: 基本的な関数作成
2. 課題9-2: 配列操作関数
3. 課題9-3: 文字列処理関数

### 中級者向け（中級課題に挑戦）
4. 課題9-4: 複数戻り値を持つ関数
5. 課題9-5: エラーハンドリング付き関数
6. 課題9-6: 構造体を使った関数

### 上級者向け（上級・挑戦課題）
7. 課題9-7: 再帰関数
8. 課題9-8: 高度な文字列処理
9. 課題9-9: ソートアルゴリズム関数
10. 課題9-10: 関数ポインター
11. 課題9-11: メモリ効率を考慮した関数
12. 課題9-12: 総合プロジェクト

## 学習のヒント

1. **段階的実装**
   - 最初は基本機能のみ実装
   - 動作確認後に機能を追加
   - テストを頻繁に実行

2. **エラーハンドリング**
   - NULLポインターのチェック
   - 配列の境界チェック
   - 無効な引数の処理

3. **関数設計の原則**
   - 単一責任の原則
   - 適切な関数名と引数名
   - const修飾子の活用

4. **テスト駆動開発**
   - 関数作成前にテストケースを考える
   - 境界値のテスト
   - エラーケースのテスト

5. **コードレビュー**
   - 他の人に読んでもらう
   - 改善点を見つける
   - ベストプラクティスを学ぶ

## 参考資料

- C言語関数リファレンス
- アルゴリズムとデータ構造の教科書
- セキュアプログラミングガイド
- 関数型プログラミングの考え方

## 実装例の構成

各課題の実装では以下の構成を推奨します：

```c
// ヘッダーファイル（functions.h）
// - 関数プロトタイプ
// - 定数定義
// - 構造体定義

// 実装ファイル（functions.c）
// - 関数の実装
// - 静的関数（内部使用）
// - エラーハンドリング

// テストファイル（test.c）
// - main関数
// - 各関数のテスト
// - 結果の検証
```

## 発展的な学習内容

1. **可変長引数**
   - va_list、va_start、va_endの使用
   - printfライクな関数の作成

2. **関数ポインター**
   - コールバック関数の実装
   - 関数テーブルの作成

3. **マクロ関数**
   - 関数ライクマクロの作成
   - 条件付きコンパイル

4. **インライン関数**
   - パフォーマンスの最適化
   - 適切な使用場面

このチュートリアルを通じて、C言語の関数について体系的に学習し、実践的なプログラミングスキルを身に付けてください。

---

# 第10章: ポインタ - 演習課題


## 基礎問題

### 演習10-1: ポインタの基本操作

2つの整数変数の値をポインタを使って交換するプログラムを作成してください。

**要件:**
- 2つの整数変数を宣言・初期化
- ポインタを使った値の交換関数を実装
- 交換前後の値とアドレスを表示
- 直接的な値の交換とポインタ経由の交換を比較

**期待される出力例:**
```
交換前: a =  (アドレス: xffffbffac), b =  (アドレス: xffffbffa)
ポインタを使った交換実行...
交換後: a =  (アドレス: xffffbffac), b =  (アドレス: xffffbffa)
```

### 演習10-2: 配列とポインタ

ポインタ演算を使って配列の要素を逆順に表示するプログラムを作成してください。

**要件:**
- 整数配列を宣言・初期化
- ポインタ演算で配列の最後から最初に向かってアクセス
- インデックス記法とポインタ記法の両方で表示
- 配列のサイズを動的に計算

### 演習10-3: 文字列操作

ポインタを使って文字列の長さを計算し、文字列を逆順にするプログラムを作成してください。

**要件:**
- 文字列の長さ計算関数（strlen相当）をポインタで実装
- 文字列を逆順にする関数をポインタで実装
- 元の文字列と逆順文字列を表示
- 文字列リテラルと文字配列の違いを考慮

## 応用問題

### 演習10-4: 配列操作関数

ポインタを使って配列の最大値、最小値、平均値を計算する関数群を作成してください。

**要件:**
- 最大値を見つけてそのポインタを返す関数
- 最小値を見つけてそのポインタを返す関数
- 平均値を計算する関数（戻り値はdouble）
- 各関数の結果を使ってレポートを作成

**実装する関数:**
```c
int* find_max(int *arr, int size);
int* find_min(int *arr, int size);
double calculate_average(int *arr, int size);
void print_statistics(int *arr, int size);
```

### 演習10-5: 文字列処理

ポインタを使って文字列の検索、置換、分割を実行する関数群を作成してください。

**要件:**
- 文字列内で特定の文字を検索する関数
- 文字列内の文字を置換する関数
- 文字列を特定の文字で分割する関数
- 大文字・小文字を無視した比較機能

### 演習10-6: データ変換

ポインタを使って配列のデータ型変換を実行するプログラムを作成してください。

**要件:**
- int配列をfloat配列に変換
- 文字列を数値配列に変換
- バイト配列を整数として解釈
- エラーハンドリングの実装

## 発展問題

### 演習10-7: メモリ操作

ポインタを使って任意のデータ型の配列をコピーする汎用関数を作成してください。

**要件:**
- void*ポインタを使った汎用コピー関数
- バイト単位でのメモリコピー
- 型安全性の考慮
- コピー対象の境界チェック

**関数プロトタイプ:**
```c
void* generic_copy(void *dest, const void *src, size_t size);
int compare_memory(const void *ptr, const void *ptr, size_t size);
```

### 演習10-8: アルゴリズム実装

ポインタを使って各種ソートアルゴリズムを実装してください。

**要件:**
- バブルソート（ポインタ版）
- 選択ソート（ポインタ版）
- 挿入ソート（ポインタ版）
- 汎用的な比較関数の使用

### 演習10-9: データ構造

ポインタを使って簡単なリンクリスト構造を実装してください。

**要件:**
- ノード構造体の定義
- リストへの要素追加・削除
- リストの走査・検索
- メモリリークの防止

**構造体例:**
```c
typedef struct Node {
    int data;
    struct Node *next;
} Node;
```

## チャレンジ問題

### 演習10-10: 動的配列シミュレータ

malloc/freeを使わずに、静的配列とポインタを使って動的配列のような動作を実現してください。

**要件:**
- 固定サイズの大きな配列をメモリプールとして使用
- 要素の追加・削除・挿入機能
- メモリの断片化管理
- ガベージコレクション機能

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex_pointer_swap.c`, `ex_array_reverse.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex_pointer_swap.c -o ex_pointer_swap
./ex_pointer_swap
```

## ヒント

### ポインタの基本
- 宣言: `int *ptr;`
- アドレス取得: `ptr = &variable;`
- 値の取得: `value = *ptr;`
- 演算: `ptr + 1` は次の要素を指す

### 安全なプログラミング
- NULLポインタのチェック: `if (ptr != NULL)`
- 配列の境界チェック
- 初期化されていないポインタの使用を避ける

### デバッグのコツ
- アドレスと値を分けて表示
- ポインタ演算の結果を段階的に確認
- コンパイラの警告に注意を払う

### よくある間違い
- `*ptr++` と `(*ptr)++` の違い
- ローカル変数のアドレスを返すこと
- 配列の範囲外アクセス
- NULLポインタの参照
---

# 第11章: 構造体 - 演習課題


## 基礎問題

### 演習11-1: 学生情報管理

学生の情報（ID、名前、年齢、成績）を格納する構造体を定義し、ポインタを使って情報を表示・更新するプログラムを作成してください。

**要件:**
- 学生情報を表す構造体を定義
- 学生情報を入力する関数を作成
- 学生情報を表示する関数を作成（ポインタ引数）
- 成績を更新する関数を作成（ポインタ引数）

**期待される動作例:**
```
学生情報を入力してください:
ID: 1001
名前: 田中太郎
年齢: 20
成績: 85.5

=== 学生情報 ===
ID: 1001
名前: 田中太郎
年齢: 20歳
成績: 85.5点

新しい成績を入力してください: 90.0
成績を更新しました。

=== 更新後の学生情報 ===
ID: 1001
名前: 田中太郎
年齢: 20歳
成績: 90.0点
```

### 演習11-2: 座標計算

2D座標を表す構造体を定義し、2点間の距離を計算する関数をポインタを使って実装してください。

**要件:**
- 座標を表す構造体（x, y）を定義
- 2点間の距離を計算する関数を作成（ポインタ引数）
- 座標を移動する関数を作成（ポインタで更新）
- math.hのsqrt関数を使用

**期待される動作例:**
```
点1の座標を入力 (x y): 0 0
点2の座標を入力 (x y): 3 4

点1: (0, 0)
点2: (3, 4)
2点間の距離: 5.00

点1を移動します。
移動量を入力 (dx dy): 1 1

移動後の点1: (1, 1)
新しい距離: 3.61
```

### 演習11-3: 商品管理

商品情報（コード、名前、価格、在庫）の構造体を作成し、構造体配列で複数商品を管理するプログラムを作成してください。

**要件:**
- 商品情報を表す構造体を定義
- 最大10個の商品を管理できる配列を用意
- 商品を追加する関数を作成
- 全商品を表示する関数を作成
- 在庫を更新する関数を作成（商品コードで検索）

**期待される動作例:**
```
=== 商品管理システム ===
1. 商品追加
2. 商品一覧表示
3. 在庫更新
0. 終了
選択: 1

商品コード: 101
商品名: ノートPC
価格: 98000
在庫数: 5
商品を追加しました。

選択: 2
=== 商品一覧 ===
コード: 101
商品名: ノートPC
価格: 98000円
在庫: 5個
```

## 応用問題

### 演習11-4: 従業員データベース

従業員情報と部署情報をネストした構造体で管理し、部署別の給与統計を算出するプログラムを作成してください。

**要件:**
- 部署情報を表す構造体（部署名、部署コード）
- 従業員情報を表す構造体（ID、名前、部署情報、給与）
- 部署別の平均給与を計算する関数
- 最高給与の従業員を検索する関数
- 構造体ポインタ配列を使用

### 演習11-5: 図書管理システム

本の情報（タイトル、著者、出版年、貸出状況）を管理し、検索・貸出・返却機能を実装してください。

**要件:**
- 書籍情報を表す構造体を定義
- 貸出状況を管理（貸出中フラグ、借りた人のID）
- タイトルで検索する関数
- 貸出処理を行う関数
- 返却処理を行う関数
- 貸出中の本一覧を表示する関数

### 演習11-6: 成績管理システム

学生と科目の構造体を使って、学生別・科目別の成績統計を管理するプログラムを作成してください。

**要件:**
- 科目情報を表す構造体（科目名、科目コード、単位数）
- 成績情報を表す構造体（学生ID、科目コード、点数、評価）
- 学生別の平均点を計算する関数
- 科目別の平均点を計算する関数
- GPA計算機能（A=4.0, B=3.0, C=2.0, D=1.0, F=0.0）

## 発展問題

### 演習11-7: 動的配列システム

構造体ポインタ配列を動的に拡張できるシステムを実装してください。

**要件:**
- 初期容量を持つ構造体ポインタ配列
- 容量が不足したら自動的に拡張する機能
- メモリ管理を適切に行う
- 要素の追加・削除機能

### 演習11-8: データソート

構造体ポインタ配列を複数の条件（名前、年齢、成績など）でソートできるプログラムを作成してください。

**要件:**
- 複数のソート基準を選択可能
- 昇順・降順の切り替え機能
- ソート用の比較関数を複数実装
- qsort関数を使用

### 演習11-9: 階層データ構造

会社組織（部署→チーム→従業員）のような階層構造を構造体とポインタで表現してください。

**要件:**
- 部署、チーム、従業員の構造体を定義
- 階層関係をポインタで表現
- 組織図を表示する関数
- 特定の部署・チームの人数を集計する関数

## 提出方法

1. 各問題に対して別々のCファイルを作成
2. ファイル名は `ex11_1_student.c`, `ex11_2_coordinate.c` のように命名
3. 各プログラムの冒頭にコメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認

## コンパイル例

```bash
gcc -std=c90 -Wall -Wextra -pedantic ex11_1_student.c -o ex11_1_student
./ex11_1_student
```

## ヒント

- 構造体のサイズに注意（パディング）
- ポインタ経由でのメンバーアクセスには->演算子を使用
- 構造体の比較は直接できないため、メンバーごとに比較
- 文字列のコピーにはstrcpy関数を使用
- 構造体を関数に渡す際は、効率のためポインタを使用することを推奨
---

# 第12章: 関数ポインタ - 演習課題


## 演習の目的
- 関数ポインタの基本概念を理解する
- コールバック関数の実装方法を習得する
- 関数ポインタ配列を活用した動的関数選択を学ぶ
- 実行時関数切り替えシステムの設計を理解する

## 演習問題

### 演習12-1: 関数ポインタの基本操作
関数ポインタを使って複数の関数を動的に呼び出すプログラムを作成してください。

**要件:**
- 2つの整数を受け取り、結果を返す関数を複数定義する
- 関数ポインタを使ってこれらの関数を呼び出す
- 関数ポインタ配列を使った実装も含める

**実装すべき関数:**
- `int maximum(int a, int b)` - 大きい方の値を返す
- `int minimum(int a, int b)` - 小さい方の値を返す  
- `int power(int a, int b)` - aのb乗を返す（簡単な実装で可）

**ファイル名:** `ex12_1_basic_function_pointer.c`

### 演習12-2: 関数選択システム
文字に基づいて関数を選択し実行するシステムを実装してください。

**要件:**
- 文字（'+', '-', '*', '/'など）に基づいて関数を選択
- 選択された関数を実行して結果を表示
- 無効な文字が指定された場合のエラーハンドリング
- 構造体を使った関数ポインタ管理

**ファイル名:** `ex12_2_function_selector.c`

### 演習12-3: 配列処理のコールバック
コールバック関数を使って配列の各要素に異なる処理を適用するプログラムを作成してください。

**要件:**
- 整数配列を処理する関数を複数定義
- コールバック関数として配列処理関数に渡す
- 処理前後の配列の状態を表示
- 動的な処理選択機能

**実装すべき処理:**
- 各要素を倍にする
- 各要素から1を引く
- 各要素の符号を反転する

**ファイル名:** `ex12_3_array_callback.c`

### 演習12-4: 関数ポインタ配列を使った計算機
関数ポインタ配列を使用した計算機プログラムを作成してください。

**要件:**
- 関数ポインタの配列を定義
- インデックスを指定して演算を選択
- 複数の演算を連続で実行可能
- 演算履歴を表示する機能
- 統計情報の収集と表示

**実装すべき演算:**
- 加算、減算、乗算、除算
- ゼロ除算のエラーハンドリング

**ファイル名:** `ex12_4_calculator_function_array.c`

## チャレンジ問題

### チャレンジ12-5: ソートアルゴリズム選択システム
異なるソートアルゴリズムを関数ポインタで切り替えるシステムを作成してください。

**要件:**
- バブルソート、選択ソート、挿入ソートを実装
- 比較関数も関数ポインタで指定（昇順/降順）
- ソート前後の配列状態を表示
- アルゴリズムの性能比較機能

**ファイル名:** `ex12_5_sort_algorithms.c`

### チャレンジ12-6: イベント駆動システム
コールバック関数を使ったイベント駆動システムを実装してください。

**要件:**
- 複数種類のイベント（開始、停止、エラー、警告）
- イベントタイプごとに異なるハンドラーを登録
- イベント発生時に適切なハンドラーを呼び出し
- イベントの優先度機能

**ファイル名:** `ex12_6_event_system.c`

## 提出方法

1. 各演習問題ごとに独立したCファイルを作成
2. ファイル名は `ex12_1.c`, `ex12_2.c` のような形式で
3. コメントで問題番号と簡単な説明を記載
4. C90規格でコンパイルできることを確認
5. C99版も作成し、`_c99.c` サフィックスを付ける

## コンパイル例

### C90準拠
```bash
gcc -std=c90 -Wall -Wextra -pedantic ex12_1_basic_function_pointer.c -o ex12_1_basic_function_pointer
```

### C99準拠
```bash
gcc -std=c99 -Wall -Wextra -pedantic ex12_1_basic_function_pointer_c99.c -o ex12_1_basic_function_pointer_c99
```

## 学習のポイント

### 関数ポインタの基本
1. **宣言**: `int (*func_ptr)(int, int);`
2. **初期化**: `func_ptr = function_name;`
3. **呼び出し**: `result = func_ptr(a, b);`
4. **配列**: `int (*operations[])(int, int) = {add, sub, mul};`

### コールバック関数
1. **概念**: 関数を引数として渡す仕組み
2. **活用**: 動的な処理選択、カスタマイズ可能な処理
3. **設計**: 関数ポインタを引数に取る関数の実装

### 実用的なテクニック
1. **関数テーブル**: 構造体による関数ポインタ管理
2. **エラーハンドリング**: 無効な関数ポインタの検出
3. **状態管理**: 関数ポインタによる状態遷移
4. **性能**: 関数ポインタ使用時のオーバーヘッド考慮

## 注意事項

- 関数ポインタは初期化前に使用しない
- 型の一致を厳密に確認する
- NULL ポインタチェックを忘れずに
- デバッグ時は関数名の確認が困難な場合がある

## 実用的な応用

これらの技術は以下のような場面で使用されます：

- **GUI フレームワーク**: イベントハンドラ
- **組み込みシステム**: 割り込みハンドラ
- **ゲーム開発**: 状態管理、AI 行動パターン
- **システムプログラミング**: プラグインシステム

## 次のステップ

この章をマスターしたら、次の章に進みましょう：
- [第13章: 高度なプログラミング技法](../advanced/)
- 関数ポインタを活用したより複雑なシステム設計
- マルチスレッドプログラミングでの関数ポインタ活用
---

# 第13章: 高度なトピック - 演習課題


## 基礎課題

### 演習13-1: プリプロセッサマクロの基本
以下の仕様を満たすプログラムを作成してください：

**仕様：**
- 数学的な定数をマクロで定義する（PI、E、黄金比など）
- 基本的な計算マクロを定義する（面積、体積など）
- 条件付きコンパイルでデバッグ機能を切り替える
- 文字列化マクロと連結マクロを活用する

**実装すべき機能：**
- 円の面積・周長計算
- 球の体積・表面積計算
- デバッグ情報の出力（条件付き）
- マクロによる型安全な最大値・最小値関数

**ファイル名：** `ex13_1_macro_basics.c`

### 演習13-2: 安全なメモリ操作マクロ
メモリ操作の安全性を向上させるマクロ群を作成してください：

**仕様：**
- NULL チェック付きメモリ割り当て
- 配列境界チェック付きアクセス
- 自動的なメモリ解放
- メモリリーク検出機能

**実装すべきマクロ：**
- `SAFE_MALLOC(size)` - NULLチェック付きmalloc
- `SAFE_FREE(ptr)` - NULLクリア付きfree
- `ARRAY_BOUNDS_CHECK(arr, index, size)` - 境界チェック
- `MEMORY_LEAK_TRACKER` - 簡単なリーク検出

**ファイル名：** `ex13_2_safe_memory.c`

### 演習13-3: 基本的なメモリプール
固定サイズオブジェクト用の簡単なメモリプールを実装してください：

**仕様：**
- 事前に確保されたメモリ領域からオブジェクトを割り当て
- フリーリストによる高速な割り当て・解放
- プールの使用状況を表示する機能
- 初期化・終了処理

**実装すべき機能：**
- プールの初期化と終了処理
- オブジェクトの取得と返却
- 使用状況の表示
- エラーハンドリング

**ファイル名：** `ex13_3_memory_pool.c`

## 応用課題

### 演習13-4: 汎用的なプリプロセッサライブラリ
さまざまな用途に使える汎用的なマクロライブラリを作成してください：

**仕様：**
- 型判定マクロ（コンパイル時）
- 汎用的なスワップマクロ
- ループ展開マクロ
- アサーション機能付きマクロ
- ベンチマーク計測マクロ

**実装すべき機能：**
- `TYPE_CHECK(a, b)` - 型の一致確認
- `GENERIC_SWAP(a, b)` - 任意の型のスワップ
- `REPEAT(n, code)` - コードの繰り返し展開
- `BENCHMARK_BLOCK(name)` - ブロックの実行時間測定
- `STATIC_ASSERT(condition, message)` - コンパイル時アサーション

**ファイル名：** `ex13_4_generic_macros.c`

### 演習13-5: 高性能メモリアロケーター
パフォーマンスを重視したカスタムメモリアロケーターを実装してください：

**仕様：**
- サイズ別メモリプール（小・中・大オブジェクト）
- メモリの断片化を最小限に抑える仕組み
- アロケーション統計情報の収集
- スレッドセーフ対応（簡易版）

**実装すべき機能：**
- 複数サイズのメモリプール管理
- First Fit / Best Fit アルゴリズム
- メモリ使用統計とレポート機能
- デバッグモードでの詳細トレース

**ファイル名：** `ex13_5_allocator.c`

### 演習13-6: キャッシュフレンドリーなデータ構造
CPU キャッシュ効率を考慮したデータ構造を実装してください：

**仕様：**
- 配列ベースの動的配列（vector 風）
- キャッシュラインを意識したメモリレイアウト
- プリフェッチを活用した高速アクセス
- メモリプールとの連携

**実装すべき機能：**
- 動的な要素追加・削除
- キャッシュ効率的な反復処理
- バルク操作（一括挿入・削除）
- パフォーマンス測定機能

**ファイル名：** `ex13_6_cache_vector.c`

## 挑戦課題

### 演習13-7: プリプロセッサベースのDSL
プリプロセッサを使ってドメイン固有言語（DSL）を作成してください：

**仕様：**
- 状態機械を記述するDSL
- イベント駆動システムの記述
- 自動的なコード生成
- コンパイル時検証機能

**実装例：**
```c
STATE_MACHINE(TrafficLight)
    STATE(Red)    TIMEOUT() -> Yellow
    STATE(Yellow) TIMEOUT() -> Green  
    STATE(Green)  TIMEOUT() -> Red
END_STATE_MACHINE

EVENT_HANDLER(ButtonPress) 
    // イベント処理コード
END_EVENT_HANDLER
```

**ファイル名：** `ex13_7_dsl.c`

### 演習13-8: 動的メモリ管理フレームワーク
ガベージコレクション機能付きのメモリ管理フレームワークを実装してください：

**仕様：**
- 参照カウント式ガベージコレクション
- 循環参照の検出と解決
- 弱参照（weak reference）のサポート
- メモリプレッシャー対応

**実装すべき機能：**
- オブジェクトの自動管理
- 参照カウントの増減
- 循環参照のマーク&スイープ
- メモリ不足時の自動解放

**ファイル名：** `ex13_8_gc_framework.c`

### 演習13-9: リアルタイムメモリアロケーター
リアルタイムシステム向けの決定的メモリアロケーターを実装してください：

**仕様：**
- O(1) での割り当て・解放保証
- メモリ断片化の完全排除
- 予測可能なメモリ使用量
- 割り込み処理からの安全な使用

**実装すべき機能：**
- 固定時間でのメモリ操作
- 事前確保によるメモリプール
- 優先度別メモリ管理
- リアルタイム統計情報

**ファイル名：** `ex13_9_realtime.c`

## 評価基準

### 基礎課題（各10点）
- 正しく動作する：5点
- コードの可読性：3点
- エラーハンドリング：2点

### 応用課題（各15点）
- 機能の完全性：5点
- パフォーマンス：4点
- 設計の優秀さ：3点
- 拡張性：3点

### 挑戦課題（各20点）
- 実装の完成度：8点
- 創意工夫：5点
- 技術的難易度：4点
- 実用性：3点

## 提出方法

1. 各課題を指定されたファイル名で作成
2. コンパイル用のMakefileを作成
3. 実行例とパフォーマンス結果を含むREADME.mdを作成
4. すべてのファイルを`solutions/`フォルダーに配置

## 学習のポイント

### プリプロセッサの活用
- マクロの安全な使用方法
- 条件付きコンパイルの効果的な活用
- コード生成の自動化
- デバッグ支援機能

### メモリ管理の最適化
- メモリプールの設計と実装
- キャッシュ効率を考慮したデータ構造
- パフォーマンス測定と改善
- メモリリークの検出と防止

### 高度なC言語技法
- 型安全なプログラミング
- コンパイル時計算の活用
- ハードウェア特性を考慮した実装
- システムプログラミング技法

## 参考資料

### プリプロセッサ高度技法
```c
// X-マクロパターン
#define COLORS \
    X(RED, "赤") \
    X(GREEN, "緑") \
    X(BLUE, "青")

typedef enum {
#define X(name, desc) COLOR_##name,
    COLORS
#undef X
    COLOR_COUNT
} Color;

const char* color_names[] = {
#define X(name, desc) desc,
    COLORS
#undef X
};
```

### メモリアライメント最適化
```c
// キャッシュライン境界でのアライメント
#define CACHE_LINE_SIZE 64
#define CACHE_ALIGNED __attribute__((aligned(CACHE_LINE_SIZE)))

typedef struct CACHE_ALIGNED {
    int frequently_accessed_data;
    char padding[CACHE_LINE_SIZE - sizeof(int)];
} CacheOptimizedStruct;
```

### 高性能メモリ操作
```c
// SIMD命令を使った高速メモリコピー
#include <immintrin.h>

void fast_memcpy(void* dst, const void* src, size_t size) {
    // AVXを使った実装例
    if (size >= 32 && ((intptr_t)dst & 31) == 0 && ((intptr_t)src & 31) == 0) {
        // 32バイト境界でアラインされている場合の最適化
    }
}
```

## よくある間違いとその対策

### 1. マクロの副作用
**間違い：**
```c
#define SQUARE(x) x * x
int a = 5;
int result = SQUARE(++a);  // a が2回インクリメントされる
```

**正解：**
```c
#define SQUARE(x) ({ \
    typeof(x) _temp = (x); \
    _temp * _temp; \
})
```

### 2. メモリアライメントの無視
**間違い：**
```c
char buffer[100];
int* ptr = (int*)&buffer[1];  // 不正なアライメント
```

**正解：**
```c
#include <stdalign.h>
alignas(int) char buffer[100];
int* ptr = (int*)buffer;
```

### 3. キャッシュ効率の無視
**間違い：**
```c
// 列優先アクセス（キャッシュミスが多発）
for (int j = 0; j < cols; j++) {
    for (int i = 0; i < rows; i++) {
        matrix[i][j] = value;
    }
}
```

**正解：**
```c
// 行優先アクセス（キャッシュフレンドリー）
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = value;
    }
}
```

これらの課題を通じて、C言語の高度な機能を習得し、パフォーマンスを意識したプログラミングスキルを身につけてください。
---
